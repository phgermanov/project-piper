// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/spf13/cobra"
)

type sapCollectPolicyResultsOptions struct {
	JSONKeyFilePath           string   `json:"jsonKeyFilePath,omitempty"`
	Token                     string   `json:"token,omitempty"`
	PipelineRuns              []string `json:"pipelineRuns,omitempty"`
	CentralPolicyKeys         []string `json:"centralPolicyKeys,omitempty"`
	CustomPolicyKeys          []string `json:"customPolicyKeys,omitempty"`
	ValidateCompliance        bool     `json:"validateCompliance,omitempty"`
	MaxWait                   int      `json:"maxWait,omitempty"`
	GithubToken               string   `json:"githubToken,omitempty"`
	CumulusPolicyAgentVersion string   `json:"cumulusPolicyAgentVersion,omitempty"`
	ResultFile                string   `json:"resultFile,omitempty"`
}

// SapCollectPolicyResultsCommand Collect Policy Results from Cumulus
func SapCollectPolicyResultsCommand() *cobra.Command {
	const STEP_NAME = "sapCollectPolicyResults"

	metadata := sapCollectPolicyResultsMetadata()
	var stepConfig sapCollectPolicyResultsOptions
	var startTime time.Time
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapCollectPolicyResultsCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "Collect Policy Results from Cumulus",
		Long: `This step allows to collect policy results from one or more pipeline runs (specified by 'pipelieRuns') for the given central and/or custom policy keys.

The results are collected from the cumulus storage, therefore it is required that:
  - for custom policies the results has been uploaded before
  - for central policies the evidence has been uploaded before (so that cumulus has determined the result)

The compliance can be validated so that the command will fail if at least one 'NOT_COMPLIANT' policy result has been collected or is missing (parameter 'validateCompliance').
Optionally, a result file containing a summary and details can be written (parameter 'resultFile').`,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)
			log.RegisterSecret(stepConfig.JSONKeyFilePath)
			log.RegisterSecret(stepConfig.Token)
			log.RegisterSecret(stepConfig.GithubToken)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapCollectPolicyResults(stepConfig, &stepTelemetryData)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapCollectPolicyResultsFlags(createSapCollectPolicyResultsCmd, &stepConfig)
	return createSapCollectPolicyResultsCmd
}

func addSapCollectPolicyResultsFlags(cmd *cobra.Command, stepConfig *sapCollectPolicyResultsOptions) {
	cmd.Flags().StringVar(&stepConfig.JSONKeyFilePath, "jsonKeyFilePath", os.Getenv("PIPER_jsonKeyFilePath"), "File path to Google Cloud JSON key file. If this parameter is not set, the 'token' parameter will be used for authentication.")
	cmd.Flags().StringVar(&stepConfig.Token, "token", os.Getenv("PIPER_token"), "The token used to authenticate with the Google Cloud Storage service. It is provided by TrustEngine, so usually there is no need to set this parameter.")
	cmd.Flags().StringSliceVar(&stepConfig.PipelineRuns, "pipelineRuns", []string{}, "Defines the pipelineRuns and pipeline for which the Policy Results should be collected using Pipeline-ID and Version separated by a comma.")
	cmd.Flags().StringSliceVar(&stepConfig.CentralPolicyKeys, "centralPolicyKeys", []string{}, "Defines the Central Policies for which the Policy Results should be collected.")
	cmd.Flags().StringSliceVar(&stepConfig.CustomPolicyKeys, "customPolicyKeys", []string{}, "Defines the Custom Policies for which the Policy Results should be collected.")
	cmd.Flags().BoolVar(&stepConfig.ValidateCompliance, "validateCompliance", false, "Validates the compliance which means that the pipeline will fail if at least one of the collected policy results is not compliant or missing.")
	cmd.Flags().IntVar(&stepConfig.MaxWait, "maxWait", 0, "Define the time in minutes the step will wait and re-check if at least one of the collected policy results is missing.")
	cmd.Flags().StringVar(&stepConfig.GithubToken, "githubToken", os.Getenv("PIPER_githubToken"), "Token of Git user for GitHub access. Required if pipeline is running outside of the corporate network.")
	cmd.Flags().StringVar(&stepConfig.CumulusPolicyAgentVersion, "cumulusPolicyAgentVersion", `latest`, "The version of the cumulus policy agent to be used for the execution.\nNote: Normally you should use the default\n")
	cmd.Flags().StringVar(&stepConfig.ResultFile, "resultFile", os.Getenv("PIPER_resultFile"), "Relative path of the result file that is generated with all the collected policy results.\n")

	cmd.MarkFlagRequired("pipelineRuns")
}

// retrieve step metadata
func sapCollectPolicyResultsMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapCollectPolicyResults",
			Aliases:     []config.Alias{},
			Description: "Collect Policy Results from Cumulus",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Secrets: []config.StepSecrets{
					{Name: "cumulusFileCredentialsId", Description: "Jenkins 'File' credentials ID containing the key file to authenticate to Cumulus on the Google Cloud Platform.", Type: "jenkins"},
					{Name: "githubTokenCredentialsId", Description: "Jenkins 'Secret text' credentials ID containing the token used to authenticate with the Github server.", Type: "jenkins"},
				},
				Parameters: []config.StepParameters{
					{
						Name: "jsonKeyFilePath",
						ResourceRef: []config.ResourceReference{
							{
								Name: "cumulusFileCredentialsId",
								Type: "secret",
							},

							{
								Name:    "cumulusFileCredentialsVaultSecretName",
								Type:    "vaultSecretFile",
								Default: "cumulus",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_jsonKeyFilePath"),
					},
					{
						Name: "token",
						ResourceRef: []config.ResourceReference{
							{
								Name:    "cumulusSystemTrustSecretName",
								Type:    "systemTrustSecret",
								Default: "cumulus",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_token"),
					},
					{
						Name:        "pipelineRuns",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"STEPS", "PARAMETERS"},
						Type:        "[]string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     []string{},
					},
					{
						Name:        "centralPolicyKeys",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"STEPS", "PARAMETERS"},
						Type:        "[]string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     []string{},
					},
					{
						Name:        "customPolicyKeys",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"STEPS", "PARAMETERS"},
						Type:        "[]string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     []string{},
					},
					{
						Name:        "validateCompliance",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
					{
						Name:        "maxWait",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS"},
						Type:        "int",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     0,
					},
					{
						Name: "githubToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "githubTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "githubTokenCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "github",
							},
						},
						Scope:     []string{"PARAMETERS", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "access_token"}},
						Default:   os.Getenv("PIPER_githubToken"),
					},
					{
						Name:        "cumulusPolicyAgentVersion",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `latest`,
					},
					{
						Name:        "resultFile",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_resultFile"),
					},
				},
			},
		},
	}
	return theMetaData
}
