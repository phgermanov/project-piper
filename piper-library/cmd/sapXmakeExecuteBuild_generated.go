// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/gcs"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/piperenv"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/bmatcuk/doublestar"
	"github.com/spf13/cobra"
)

type sapXmakeExecuteBuildOptions struct {
	JobNamePattern       string   `json:"jobNamePattern,omitempty" validate:"possible-values=GitHub-Tools GitHub-Internal"`
	BuildType            string   `json:"buildType,omitempty" validate:"possible-values=xMakeStage xMakePromote"`
	JobParameters        []string `json:"jobParameters,omitempty"`
	BuildQuality         string   `json:"buildQuality,omitempty" validate:"possible-values=Milestone Release"`
	ShipmentType         string   `json:"shipmentType,omitempty"`
	Owner                string   `json:"owner,omitempty"`
	Repository           string   `json:"repository,omitempty"`
	Username             string   `json:"username,omitempty"`
	Token                string   `json:"token,omitempty"`
	CommitID             string   `json:"commitId,omitempty"`
	StagingRepositoryID  string   `json:"stagingRepositoryId,omitempty"`
	XMakeJobName         string   `json:"xMakeJobName,omitempty"`
	XMakeJobNameTemplate string   `json:"xMakeJobNameTemplate,omitempty"`
	ArtifactPattern      string   `json:"artifactPattern,omitempty"`
}

type sapXmakeExecuteBuildCommonPipelineEnvironment struct {
	custom struct {
		releaseStatus            string
		xmakeDeployPackage       string
		xmakeStagingRepositoryID string
		xmakeJobURL              string
		stageBOM                 map[string]interface{}
		promotedArtifactURLs     []string
	}
	container struct {
		imageNames         []string
		imageNameTags      []string
		registryURL        string
		repositoryUsername string
		repositoryPassword string
	}
}

func (p *sapXmakeExecuteBuildCommonPipelineEnvironment) persist(path, resourceName string) {
	content := []struct {
		category string
		name     string
		value    interface{}
	}{
		{category: "custom", name: "releaseStatus", value: p.custom.releaseStatus},
		{category: "custom", name: "xmakeDeployPackage", value: p.custom.xmakeDeployPackage},
		{category: "custom", name: "xmakeStagingRepositoryId", value: p.custom.xmakeStagingRepositoryID},
		{category: "custom", name: "xmakeJobUrl", value: p.custom.xmakeJobURL},
		{category: "custom", name: "stageBOM", value: p.custom.stageBOM},
		{category: "custom", name: "promotedArtifactUrls", value: p.custom.promotedArtifactURLs},
		{category: "container", name: "imageNames", value: p.container.imageNames},
		{category: "container", name: "imageNameTags", value: p.container.imageNameTags},
		{category: "container", name: "registryUrl", value: p.container.registryURL},
		{category: "container", name: "repositoryUsername", value: p.container.repositoryUsername},
		{category: "container", name: "repositoryPassword", value: p.container.repositoryPassword},
	}

	errCount := 0
	for _, param := range content {
		err := piperenv.SetResourceParameter(path, resourceName, filepath.Join(param.category, param.name), param.value)
		if err != nil {
			log.Entry().WithError(err).Error("Error persisting piper environment.")
			errCount++
		}
	}
	if errCount > 0 {
		log.Entry().Error("failed to persist Piper environment")
	}
}

type sapXmakeExecuteBuildInflux struct {
	step_data struct {
		fields struct {
			xmakestage    string
			xmakepromote  string
			build_quality string
		}
		tags struct {
		}
	}
}

func (i *sapXmakeExecuteBuildInflux) persist(path, resourceName string) {
	measurementContent := []struct {
		measurement string
		valType     string
		name        string
		value       interface{}
	}{
		{valType: config.InfluxField, measurement: "step_data", name: "xmakestage", value: i.step_data.fields.xmakestage},
		{valType: config.InfluxField, measurement: "step_data", name: "xmakepromote", value: i.step_data.fields.xmakepromote},
		{valType: config.InfluxField, measurement: "step_data", name: "build_quality", value: i.step_data.fields.build_quality},
	}

	errCount := 0
	for _, metric := range measurementContent {
		err := piperenv.SetResourceParameter(path, resourceName, filepath.Join(metric.measurement, fmt.Sprintf("%vs", metric.valType), metric.name), metric.value)
		if err != nil {
			log.Entry().WithError(err).Error("Error persisting influx environment.")
			errCount++
		}
	}
	if errCount > 0 {
		log.Entry().Error("failed to persist Influx environment")
	}
}

type sapXmakeExecuteBuildReports struct {
}

func (p *sapXmakeExecuteBuildReports) persist(stepConfig sapXmakeExecuteBuildOptions, gcpJsonKeyFilePath string, gcsBucketId string, gcsFolderPath string, gcsSubFolder string) {
	if gcsBucketId == "" {
		log.Entry().Info("persisting reports to GCS is disabled, because gcsBucketId is empty")
		return
	}
	log.Entry().Info("Uploading reports to Google Cloud Storage...")
	content := []gcs.ReportOutputParam{
		{FilePattern: "**/build-type.json", ParamRef: "", StepResultType: "xmake"},
		{FilePattern: "**/sbom/**/bom.xml", ParamRef: "", StepResultType: "xmake"},
	}

	gcsClient, err := gcs.NewClient(gcpJsonKeyFilePath, "")
	if err != nil {
		log.Entry().Errorf("creation of GCS client failed: %v", err)
		return
	}
	defer gcsClient.Close()
	structVal := reflect.ValueOf(&stepConfig).Elem()
	inputParameters := map[string]string{}
	for i := 0; i < structVal.NumField(); i++ {
		field := structVal.Type().Field(i)
		if field.Type.String() == "string" {
			paramName := strings.Split(field.Tag.Get("json"), ",")
			paramValue, _ := structVal.Field(i).Interface().(string)
			inputParameters[paramName[0]] = paramValue
		}
	}
	if err := gcs.PersistReportsToGCS(gcsClient, content, inputParameters, gcsFolderPath, gcsBucketId, gcsSubFolder, doublestar.Glob, os.Stat); err != nil {
		log.Entry().Errorf("failed to persist reports: %v", err)
	}
}

// SapXmakeExecuteBuildCommand This step executes a job in the xMake Central Build Service.
func SapXmakeExecuteBuildCommand() *cobra.Command {
	const STEP_NAME = "sapXmakeExecuteBuild"

	metadata := sapXmakeExecuteBuildMetadata()
	var stepConfig sapXmakeExecuteBuildOptions
	var startTime time.Time
	var commonPipelineEnvironment sapXmakeExecuteBuildCommonPipelineEnvironment
	var influx sapXmakeExecuteBuildInflux
	var reports sapXmakeExecuteBuildReports
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapXmakeExecuteBuildCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "This step executes a job in the xMake Central Build Service.",
		Long: `For xMake details please see the documentation of [xMake Central Build Service](https://github.wdf.sap.corp/pages/xmake-ci/User-Guide/).

!!! note This step is used implicitly by the step [executeBuild](executeBuild.md).

To use the imagePushToRegistry step with a multi-arch Docker build, use the [useImageNameTags parameter](https://go.sap.corp/piper/steps/imagePushToRegistry/#sourceimagetag).`,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)
			log.RegisterSecret(stepConfig.Username)
			log.RegisterSecret(stepConfig.Token)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				commonPipelineEnvironment.persist(piperOsCmd.GeneralConfig.EnvRootPath, "commonPipelineEnvironment")
				influx.persist(piperOsCmd.GeneralConfig.EnvRootPath, "influx")
				reports.persist(stepConfig, piperOsCmd.GeneralConfig.GCPJsonKeyFilePath, piperOsCmd.GeneralConfig.GCSBucketId, piperOsCmd.GeneralConfig.GCSFolderPath, piperOsCmd.GeneralConfig.GCSSubFolder)
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapXmakeExecuteBuild(stepConfig, &stepTelemetryData, &commonPipelineEnvironment, &influx)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapXmakeExecuteBuildFlags(createSapXmakeExecuteBuildCmd, &stepConfig)
	return createSapXmakeExecuteBuildCmd
}

func addSapXmakeExecuteBuildFlags(cmd *cobra.Command, stepConfig *sapXmakeExecuteBuildOptions) {
	cmd.Flags().StringVar(&stepConfig.JobNamePattern, "jobNamePattern", `GitHub-Internal`, "The pattern that should be used to generate the job name.")
	cmd.Flags().StringVar(&stepConfig.BuildType, "buildType", `xMakeStage`, "Defines the type of build to be executed.")
	cmd.Flags().StringSliceVar(&stepConfig.JobParameters, "jobParameters", []string{}, "Defines additional configuration options that are passed as job parameters to the build job.")
	cmd.Flags().StringVar(&stepConfig.BuildQuality, "buildQuality", `Milestone`, "Defines the build quality for the build job.")
	cmd.Flags().StringVar(&stepConfig.ShipmentType, "shipmentType", `indirectshipment`, "Defines the type of the shipment. This will be part of the automatically generated job name (only applicable for build quality 'Release').")
	cmd.Flags().StringVar(&stepConfig.Owner, "owner", os.Getenv("PIPER_owner"), "Defines the name of the GitHub organization. This will be part of the automatically generated job name.")
	cmd.Flags().StringVar(&stepConfig.Repository, "repository", os.Getenv("PIPER_repository"), "Defines the name of the GitHub repository. This will be part of the automatically generated job name.")
	cmd.Flags().StringVar(&stepConfig.Username, "username", os.Getenv("PIPER_username"), "The username to authenticate with the build environment.")
	cmd.Flags().StringVar(&stepConfig.Token, "token", os.Getenv("PIPER_token"), "The user token to authenticate with the build environment.")
	cmd.Flags().StringVar(&stepConfig.CommitID, "commitId", os.Getenv("PIPER_commitId"), "Defines the git commit id which should be the source of the build job.")
	cmd.Flags().StringVar(&stepConfig.StagingRepositoryID, "stagingRepositoryId", os.Getenv("PIPER_stagingRepositoryId"), "Defines the id of the repository containing the artifact created during the staging build job.")
	cmd.Flags().StringVar(&stepConfig.XMakeJobName, "xMakeJobName", os.Getenv("PIPER_xMakeJobName"), "DEPRECATED: This legacy parameter is ONLY used to derive the [jobNamePattern](#jobnamepattern).")
	cmd.Flags().StringVar(&stepConfig.XMakeJobNameTemplate, "xMakeJobNameTemplate", os.Getenv("PIPER_xMakeJobNameTemplate"), "DEPRECATED: This legacy parameter is ONLY used to derive the [jobNamePattern](#jobnamepattern).")
	cmd.Flags().StringVar(&stepConfig.ArtifactPattern, "artifactPattern", os.Getenv("PIPER_artifactPattern"), "Defines a pattern (glob style) to select the artifact(s) exported to the pipeline environment (e.g. '{*.war,*.zip}', '*.jar').")

	cmd.MarkFlagRequired("owner")
	cmd.MarkFlagRequired("repository")
	cmd.MarkFlagRequired("username")
	cmd.MarkFlagRequired("token")
	cmd.MarkFlagRequired("commitId")
}

// retrieve step metadata
func sapXmakeExecuteBuildMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapXmakeExecuteBuild",
			Aliases:     []config.Alias{{Name: "executeBuild", Deprecated: false}, {Name: "triggerXMakeRemoteJob", Deprecated: true}},
			Description: "This step executes a job in the xMake Central Build Service.",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Secrets: []config.StepSecrets{
					{Name: "xMakeCredentialsId", Type: "jenkins", Aliases: []config.Alias{{Name: "xMakeNovaCredentialsId", Deprecated: false}, {Name: "xMakeDevCredentialsId", Deprecated: false}}},
				},
				Parameters: []config.StepParameters{
					{
						Name:        "jobNamePattern",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `GitHub-Internal`,
					},
					{
						Name:        "buildType",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `xMakeStage`,
					},
					{
						Name:        "jobParameters",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "[]string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "xMakeJobParameters"}},
						Default:     []string{},
					},
					{
						Name:        "buildQuality",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "xMakeBuildQuality"}},
						Default:     `Milestone`,
					},
					{
						Name:        "shipmentType",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "xMakeShipmentType"}},
						Default:     `indirectshipment`,
					},
					{
						Name: "owner",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "github/owner",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{{Name: "githubOrg"}},
						Default:   os.Getenv("PIPER_owner"),
					},
					{
						Name: "repository",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "github/repository",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{{Name: "githubRepo"}},
						Default:   os.Getenv("PIPER_repository"),
					},
					{
						Name: "username",
						ResourceRef: []config.ResourceReference{
							{
								Name:    "xMakeCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "xmake",
							},

							{
								Name:  "xMakeCredentialsId",
								Param: "username",
								Type:  "secret",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_username"),
					},
					{
						Name: "token",
						ResourceRef: []config.ResourceReference{
							{
								Name:    "xMakeCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "xmake",
							},

							{
								Name:  "xMakeCredentialsId",
								Param: "password",
								Type:  "secret",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_token"),
					},
					{
						Name: "commitId",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/commitId",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{{Name: "gitCommitId"}},
						Default:   os.Getenv("PIPER_commitId"),
					},
					{
						Name: "stagingRepositoryId",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "custom/xmakeStagingRepositoryId",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "xMakeStagingRepoId"}},
						Default:   os.Getenv("PIPER_stagingRepositoryId"),
					},
					{
						Name:        "xMakeJobName",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_xMakeJobName"),
					},
					{
						Name:        "xMakeJobNameTemplate",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_xMakeJobNameTemplate"),
					},
					{
						Name:        "artifactPattern",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_artifactPattern"),
					},
				},
			},
			Outputs: config.StepOutputs{
				Resources: []config.StepResources{
					{
						Name: "commonPipelineEnvironment",
						Type: "piperEnvironment",
						Parameters: []map[string]interface{}{
							{"name": "custom/releaseStatus"},
							{"name": "custom/xmakeDeployPackage"},
							{"name": "custom/xmakeStagingRepositoryId"},
							{"name": "custom/xmakeJobUrl"},
							{"name": "custom/stageBOM", "type": "map[string]interface{}"},
							{"name": "custom/promotedArtifactUrls", "type": "[]string"},
							{"name": "container/imageNames", "type": "[]string"},
							{"name": "container/imageNameTags", "type": "[]string"},
							{"name": "container/registryUrl"},
							{"name": "container/repositoryUsername"},
							{"name": "container/repositoryPassword"},
						},
					},
					{
						Name: "influx",
						Type: "influx",
						Parameters: []map[string]interface{}{
							{"name": "step_data", "fields": []map[string]string{{"name": "xmakestage"}, {"name": "xmakepromote"}, {"name": "build_quality"}}},
						},
					},
					{
						Name: "reports",
						Type: "reports",
						Parameters: []map[string]interface{}{
							{"filePattern": "**/build-type.json", "type": "xmake"},
							{"filePattern": "**/sbom/**/bom.xml", "type": "xmake"},
						},
					},
				},
			},
		},
	}
	return theMetaData
}
