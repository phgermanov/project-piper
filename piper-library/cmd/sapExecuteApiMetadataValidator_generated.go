// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/gcs"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/bmatcuk/doublestar"
	"github.com/spf13/cobra"
)

type sapExecuteApiMetadataValidatorOptions struct {
	Files          []string `json:"files,omitempty"`
	Ruleset        string   `json:"ruleset,omitempty"`
	FailSeverity   string   `json:"failSeverity,omitempty"`
	Quiet          bool     `json:"quiet,omitempty"`
	PrintToConsole bool     `json:"printToConsole,omitempty"`
}

type sapExecuteApiMetadataValidatorReports struct {
}

func (p *sapExecuteApiMetadataValidatorReports) persist(stepConfig sapExecuteApiMetadataValidatorOptions, gcpJsonKeyFilePath string, gcsBucketId string, gcsFolderPath string, gcsSubFolder string) {
	if gcsBucketId == "" {
		log.Entry().Info("persisting reports to GCS is disabled, because gcsBucketId is empty")
		return
	}
	log.Entry().Info("Uploading reports to Google Cloud Storage...")
	content := []gcs.ReportOutputParam{
		{FilePattern: "**/api-metadata-validator-results.json", ParamRef: "", StepResultType: "api-metadata-validator"},
	}

	gcsClient, err := gcs.NewClient(gcpJsonKeyFilePath, "")
	if err != nil {
		log.Entry().Errorf("creation of GCS client failed: %v", err)
		return
	}
	defer gcsClient.Close()
	structVal := reflect.ValueOf(&stepConfig).Elem()
	inputParameters := map[string]string{}
	for i := 0; i < structVal.NumField(); i++ {
		field := structVal.Type().Field(i)
		if field.Type.String() == "string" {
			paramName := strings.Split(field.Tag.Get("json"), ",")
			paramValue, _ := structVal.Field(i).Interface().(string)
			inputParameters[paramName[0]] = paramValue
		}
	}
	if err := gcs.PersistReportsToGCS(gcsClient, content, inputParameters, gcsFolderPath, gcsBucketId, gcsSubFolder, doublestar.Glob, os.Stat); err != nil {
		log.Entry().Errorf("failed to persist reports: %v", err)
	}
}

// SapExecuteApiMetadataValidatorCommand Execute SAP API Metadata Validator
func SapExecuteApiMetadataValidatorCommand() *cobra.Command {
	const STEP_NAME = "sapExecuteApiMetadataValidator"

	metadata := sapExecuteApiMetadataValidatorMetadata()
	var stepConfig sapExecuteApiMetadataValidatorOptions
	var startTime time.Time
	var reports sapExecuteApiMetadataValidatorReports
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapExecuteApiMetadataValidatorCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "Execute SAP API Metadata Validator",
		Long: `This step is a wrapper around [SAP API Metadata Validator](https://github.tools.sap/CentralEngineering/api-metadata-validator/) tooling.
For more details, please visit the project repository.

By default, this step uses a docker image from internal artifactory. Additionally, there is a docker image available on Internet Facing
Artifactory (common): ` + "`" + `cpa-docker.common.repositories.cloud.sap/api-metadata-validator:latest` + "`" + `. To use it, you need to define it explicitly
in the step configuration using ` + "`" + `dockerImage` + "`" + ` property. Example:

` + "`" + `` + "`" + `` + "`" + `
sapExecuteApiMetadataValidator:
  dockerImage: cpa-docker.common.repositories.cloud.sap/api-metadata-validator:latest
  files:
    - '**/*.json'
` + "`" + `` + "`" + `` + "`" + `

This step always returns results in JSON format (due to Cumulus integration it's not possible to configure a custom formatter using this wrapper).

The validator will always save the validation results in ` + "`" + `api-metadata-validator-results.json` + "`" + ` file in the current working directory.

The step will return non-zero exit code if there is at least one validation message with a severity **Error** (default behavior). However, it's
always possible to increase the compliance level by using ` + "`" + `failSeverity` + "`" + ` parameter.

This step is part of the **General Purpose Pipeline** and can be activated by the declarative configuration:
` + "`" + `` + "`" + `` + "`" + `` + "`" + `
stages:
  Central Build:
    sapExecuteApiMetadataValidator: true
` + "`" + `` + "`" + `` + "`" + `

**Cumulus support**. The validator supports Cumulus. In case of General Purpose Pipeline the upload will happen automatically (in case that Cumulus is activated), in
custom pipelines it's possible to use the following call to upload the results:
` + "`" + `` + "`" + `` + "`" + `
sapCumulusUpload script: script, filePattern: '**/api-metadata-validator-results.json', stepResultType: 'api-metadata-validator'
` + "`" + `` + "`" + `` + "`" + ``,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				reports.persist(stepConfig, piperOsCmd.GeneralConfig.GCPJsonKeyFilePath, piperOsCmd.GeneralConfig.GCSBucketId, piperOsCmd.GeneralConfig.GCSFolderPath, piperOsCmd.GeneralConfig.GCSSubFolder)
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapExecuteApiMetadataValidator(stepConfig, &stepTelemetryData)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapExecuteApiMetadataValidatorFlags(createSapExecuteApiMetadataValidatorCmd, &stepConfig)
	return createSapExecuteApiMetadataValidatorCmd
}

func addSapExecuteApiMetadataValidatorFlags(cmd *cobra.Command, stepConfig *sapExecuteApiMetadataValidatorOptions) {
	cmd.Flags().StringSliceVar(&stepConfig.Files, "files", []string{}, "YAML/JSON documents as files (use '*' as wildcard based on glob-pattern).")
	cmd.Flags().StringVar(&stepConfig.Ruleset, "ruleset", os.Getenv("PIPER_ruleset"), "Predefined ruleset name, e.g. sap:base:v1, sap:core:v1, etc.")
	cmd.Flags().StringVar(&stepConfig.FailSeverity, "failSeverity", os.Getenv("PIPER_failSeverity"), "Defines a lower severity barrier when validator should return non-zero exit code.")
	cmd.Flags().BoolVar(&stepConfig.Quiet, "quiet", false, "Disables rules with severity \"Info\" and \"Warning\" (except unrecognized-format rule). If set, only rules with severity \"Error\" will be run and reported.")
	cmd.Flags().BoolVar(&stepConfig.PrintToConsole, "printToConsole", false, "Pretty prints the validation results in the stdout (in addition to already saved results in `api-metadata-validator-results.json`). Requires v3.0 or newer.")

	cmd.MarkFlagRequired("files")
}

// retrieve step metadata
func sapExecuteApiMetadataValidatorMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapExecuteApiMetadataValidator",
			Aliases:     []config.Alias{},
			Description: "Execute SAP API Metadata Validator",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Parameters: []config.StepParameters{
					{
						Name:        "files",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "[]string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     []string{},
					},
					{
						Name:        "ruleset",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_ruleset"),
					},
					{
						Name:        "failSeverity",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_failSeverity"),
					},
					{
						Name:        "quiet",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
					{
						Name:        "printToConsole",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
				},
			},
			Containers: []config.Container{
				{Name: "api-metadata-validator", Image: "cpa-docker.int.repositories.cloud.sap/api-metadata-validator:latest"},
			},
			Outputs: config.StepOutputs{
				Resources: []config.StepResources{
					{
						Name: "reports",
						Type: "reports",
						Parameters: []map[string]interface{}{
							{"filePattern": "**/api-metadata-validator-results.json", "type": "api-metadata-validator"},
						},
					},
				},
			},
		},
	}
	return theMetaData
}
