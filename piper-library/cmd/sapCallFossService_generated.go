// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/piperenv"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/spf13/cobra"
)

type sapCallFossServiceOptions struct {
	Username               string `json:"username,omitempty"`
	Password               string `json:"password,omitempty"`
	PipelineIDentification string `json:"pipelineIdentification,omitempty"`
	ScmIDentification      string `json:"scmIdentification,omitempty"`
	PredecessorVia         string `json:"predecessorVia,omitempty"`
	AnalyzeRequestBody     string `json:"analyzeRequestBody,omitempty"`
	CallAPI                string `json:"callApi,omitempty"`
	FossBaseURL            string `json:"fossBaseUrl,omitempty"`
}

type sapCallFossServiceCommonPipelineEnvironment struct {
	foss struct {
		resultJSON string
	}
}

func (p *sapCallFossServiceCommonPipelineEnvironment) persist(path, resourceName string) {
	content := []struct {
		category string
		name     string
		value    interface{}
	}{
		{category: "foss", name: "resultJson", value: p.foss.resultJSON},
	}

	errCount := 0
	for _, param := range content {
		err := piperenv.SetResourceParameter(path, resourceName, filepath.Join(param.category, param.name), param.value)
		if err != nil {
			log.Entry().WithError(err).Error("Error persisting piper environment.")
			errCount++
		}
	}
	if errCount > 0 {
		log.Entry().Error("failed to persist Piper environment")
	}
}

// SapCallFossServiceCommand Call Foss Service
func SapCallFossServiceCommand() *cobra.Command {
	const STEP_NAME = "sapCallFossService"

	metadata := sapCallFossServiceMetadata()
	var stepConfig sapCallFossServiceOptions
	var startTime time.Time
	var commonPipelineEnvironment sapCallFossServiceCommonPipelineEnvironment
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapCallFossServiceCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "Call Foss Service",
		Long: `This step allows to call all FOSS Service API methods and implements a default integration process.
It is currently in **BETA** mode, thus incompatible changes may occur although we aim to limit those kind of changes.

You find details about Foss in the [Foss Service Documentation](https://github.wdf.sap.corp/pages/DLM-CoDePipeS/CoDePipeS/Howto/Freeware%20and%20Open%20Source/)

By default, this step calls the api method 'analyze' and tries to 'compare' this result with a previous one (if found).
The FOSS Service will find you previous runs, if 'pipelineIdentification' or 'scmIdentification' is given. If your target is
PPMS and the given PPMS Build Version does not exist in PPMS, it is automatically created. The PPMS Change Request
is also send automatically, if PPMS is not up to date. As a precondition, proper PPMS credentials must be given. If
PPMS credentials are missing all PPMS updates are siglently skipped.

PipelineIdentification/scmIdentification:

The 'pipelineIdentification' and the 'scmIdentification' are first of all client given datapoints that help are
maintained with the FOSS Service result and helps the client to find and link the data. Both identifications help
the FOSS Service to search for a preceding analysis and compare its result with the current one ('compare' method
enablement for the default behavior).

pipelineIdentification:

The caller can provide a so-called 'global pipeline identifier' as UUID. In addition, you can send a 'pipeline instance id'
as UUID and the 'job URL'. The same job (or pipeline) should always send the same 'global pipeline identifier'. The optional
'pipeline instance id' and 'job URL' is used to provide you with a proper back reference in the result (e.g. if you browse
the result via FOSS UI).

    Format: <global pipeline identifier>;<pipeline instance id>;<job URL>
    Example: f3ece352-5eee-11ea-bc55-0242ac130003;fb37d16c-5eee-11ea-bc55-0242ac130003;https://foss.codepipes.wdf.sap.corp/job/DLM-FOSS/view/Foss%20CI%20Pipeline/
    (escape char: '\\', separator: ';')


scmIdentification:

The caller can provide its 'SCM repository URL' and the 'revision' (e.g. sha1 of git, a branch, or, a tag). In addition, this
information is used to provide a proper back reference in the result (e.g. if you browse the result via FOSS UI).

    Format: <SCM repository URL>;<revision>
    Example: https://github.wdf.sap.corp/DLM-FOSS/Foss;master
    (escape char: '\\', separator: ';')

If both, 'pipelineIdentification' and 'scmIdentification' is given, the parameter 'predecessorVia' determines which
identification is used to find the preceding analysis (fallback is 'pipelineIdentification')

callApi:

You can use this parameter to force this step to call a dedicated FOSS Service api method instead of the default
step behavior. To do this, you have to give the api method name followed by all needed parameters separated by
semicolon. In every case the result is delivered as JSON.

The following api methods are available
(please compare to pkg/fossService/fossService.go#RawApi):

    * analyze;request <JsonObjectString>
    * compare;source <uuid.UUID>;target <uuid.UUID>
    * getResultCertificate;resultId <uuid.UUID>
    * sendPpmsChangeRequest;request <JsonObjectString>
    * createPpmsBuildVersion;request <JsonObjectString>
    (escape char: '\\', separator: ';')`,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)
			log.RegisterSecret(stepConfig.Username)
			log.RegisterSecret(stepConfig.Password)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				commonPipelineEnvironment.persist(piperOsCmd.GeneralConfig.EnvRootPath, "commonPipelineEnvironment")
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapCallFossService(stepConfig, &stepTelemetryData, &commonPipelineEnvironment)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapCallFossServiceFlags(createSapCallFossServiceCmd, &stepConfig)
	return createSapCallFossServiceCmd
}

func addSapCallFossServiceFlags(cmd *cobra.Command, stepConfig *sapCallFossServiceOptions) {
	cmd.Flags().StringVar(&stepConfig.Username, "username", os.Getenv("PIPER_username"), "PPMS user that is allowed to update ppms.")
	cmd.Flags().StringVar(&stepConfig.Password, "password", os.Getenv("PIPER_password"), "PPMS password for the given PPMS user.")
	cmd.Flags().StringVar(&stepConfig.PipelineIDentification, "pipelineIdentification", os.Getenv("PIPER_pipelineIdentification"), "Informs the foss service about important pipeline parameters. See description for details.")
	cmd.Flags().StringVar(&stepConfig.ScmIDentification, "scmIdentification", os.Getenv("PIPER_scmIdentification"), "Informs the foss service about important scm parameters. See description for details.")
	cmd.Flags().StringVar(&stepConfig.PredecessorVia, "predecessorVia", os.Getenv("PIPER_predecessorVia"), "Can be set to 'pipelineIdentification' or 'scmIdentification' to define precedence if needed.")
	cmd.Flags().StringVar(&stepConfig.AnalyzeRequestBody, "analyzeRequestBody", os.Getenv("PIPER_analyzeRequestBody"), "Json formatted string to define your analyze request used to run the default behavior.")
	cmd.Flags().StringVar(&stepConfig.CallAPI, "callApi", `stepBehavior`, "Runs a dedicated foss API. See description for details.")
	cmd.Flags().StringVar(&stepConfig.FossBaseURL, "fossBaseUrl", `https://foss-service.wdf.sap.corp`, "Foss Service Base URL.")

}

// retrieve step metadata
func sapCallFossServiceMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapCallFossService",
			Aliases:     []config.Alias{},
			Description: "Call Foss Service",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Secrets: []config.StepSecrets{
					{Name: "ppmsCredentialsId", Type: "jenkins"},
				},
				Parameters: []config.StepParameters{
					{
						Name: "username",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "ppmsCredentialsId",
								Param: "username",
								Type:  "secret",
							},

							{
								Name:    "ppmsCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "ppms",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "ppmsUsername"}},
						Default:   os.Getenv("PIPER_username"),
					},
					{
						Name: "password",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "ppmsCredentialsId",
								Param: "password",
								Type:  "secret",
							},

							{
								Name:    "ppmsCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "ppms",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "ppmsPassword"}},
						Default:   os.Getenv("PIPER_password"),
					},
					{
						Name:        "pipelineIdentification",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_pipelineIdentification"),
					},
					{
						Name:        "scmIdentification",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_scmIdentification"),
					},
					{
						Name:        "predecessorVia",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_predecessorVia"),
					},
					{
						Name:        "analyzeRequestBody",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_analyzeRequestBody"),
					},
					{
						Name:        "callApi",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `stepBehavior`,
					},
					{
						Name:        "fossBaseUrl",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `https://foss-service.wdf.sap.corp`,
					},
				},
			},
			Outputs: config.StepOutputs{
				Resources: []config.StepResources{
					{
						Name: "commonPipelineEnvironment",
						Type: "piperEnvironment",
						Parameters: []map[string]interface{}{
							{"name": "foss/resultJson"},
						},
					},
				},
			},
		},
	}
	return theMetaData
}
