//go:build unit
// +build unit

package cmd

import (
	"fmt"
	piperMocks "github.com/SAP/jenkins-library/pkg/mock"
	"github.com/SAP/jenkins-library/pkg/orchestrator"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.wdf.sap.corp/ContinuousDelivery/piper-library/pkg/sap/dwc"
	"k8s.io/utils/strings/slices"
	"path/filepath"
	"testing"
)

// sapDwCStageReleaseMockUtils is an autogenerated mock type for the sapDwCStageReleaseUtils type
type sapDwCStageReleaseMockUtils struct {
	mock.Mock
	*piperMocks.FilesMock
}

// DetectOrchestrator provides a mock function with no fields
func (_m *sapDwCStageReleaseMockUtils) DetectOrchestrator() orchestrator.Orchestrator {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DetectOrchestrator")
	}

	var r0 orchestrator.Orchestrator
	if rf, ok := ret.Get(0).(func() orchestrator.Orchestrator); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(orchestrator.Orchestrator)
	}

	return r0
}

// GetMetadataEntry provides a mock function with given fields: element
func (_m *sapDwCStageReleaseMockUtils) GetMetadataEntry(element string) (string, error) {
	ret := _m.Called(element)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadataEntry")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(element)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(element)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(element)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallDwCCli provides a mock function with given fields: githubToken
func (_m *sapDwCStageReleaseMockUtils) InstallDwCCli(githubToken string) error {
	ret := _m.Called(githubToken)

	if len(ret) == 0 {
		panic("no return value specified for InstallDwCCli")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(githubToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LoginToDwCCli provides a mock function with given fields: loginDescriptor
func (_m *sapDwCStageReleaseMockUtils) LoginToDwCCli(loginDescriptor dwc.LoginDescriptor) error {
	ret := _m.Called(loginDescriptor)

	if len(ret) == 0 {
		panic("no return value specified for LoginToDwCCli")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(dwc.LoginDescriptor) error); ok {
		r0 = rf(loginDescriptor)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LookupEnv provides a mock function with given fields: variable
func (_m *sapDwCStageReleaseMockUtils) LookupEnv(variable string) (string, bool) {
	ret := _m.Called(variable)

	if len(ret) == 0 {
		panic("no return value specified for LookupEnv")
	}

	var r0 string
	var r1 bool
	if rf, ok := ret.Get(0).(func(string) (string, bool)); ok {
		return rf(variable)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(variable)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(variable)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// ResolveContainerImageURL provides a mock function with given fields: promotedDockerImage, artifactVersion
func (_m *sapDwCStageReleaseMockUtils) ResolveContainerImageURL(promotedDockerImage string, artifactVersion string) (string, string, error) {
	ret := _m.Called(promotedDockerImage, artifactVersion)

	if len(ret) == 0 {
		panic("no return value specified for ResolveContainerImageURL")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string) (string, string, error)); ok {
		return rf(promotedDockerImage, artifactVersion)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(promotedDockerImage, artifactVersion)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) string); ok {
		r1 = rf(promotedDockerImage, artifactVersion)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, string) error); ok {
		r2 = rf(promotedDockerImage, artifactVersion)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ResolveDefaultResourceName provides a mock function with given fields: collector
func (_m *sapDwCStageReleaseMockUtils) ResolveDefaultResourceName(collector dwc.MetadataCollector) (string, error) {
	ret := _m.Called(collector)

	if len(ret) == 0 {
		panic("no return value specified for ResolveDefaultResourceName")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(dwc.MetadataCollector) (string, error)); ok {
		return rf(collector)
	}
	if rf, ok := ret.Get(0).(func(dwc.MetadataCollector) string); ok {
		r0 = rf(collector)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(dwc.MetadataCollector) error); ok {
		r1 = rf(collector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Untar provides a mock function with given fields: tarArchive, destination, extractionLevel
func (_m *sapDwCStageReleaseMockUtils) Untar(tarArchive string, destination string, extractionLevel int) error {
	ret := _m.Called(tarArchive, destination, extractionLevel)

	if len(ret) == 0 {
		panic("no return value specified for Untar")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int) error); ok {
		r0 = rf(tarArchive, destination, extractionLevel)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Unzip provides a mock function with given fields: tarArchive, destination
func (_m *sapDwCStageReleaseMockUtils) Unzip(tarArchive string, destination string) error {
	ret := _m.Called(tarArchive, destination)

	if len(ret) == 0 {
		panic("no return value specified for Unzip")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(tarArchive, destination)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UploadArtifact provides a mock function with given fields: artifactDescriptor
func (_m *sapDwCStageReleaseMockUtils) UploadArtifact(artifactDescriptor dwc.ArtifactDescriptor) (*dwc.ArtifactUploadResponse, error) {
	ret := _m.Called(artifactDescriptor)

	if len(ret) == 0 {
		panic("no return value specified for UploadArtifact")
	}

	var r0 *dwc.ArtifactUploadResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(dwc.ArtifactDescriptor) (*dwc.ArtifactUploadResponse, error)); ok {
		return rf(artifactDescriptor)
	}
	if rf, ok := ret.Get(0).(func(dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse); ok {
		r0 = rf(artifactDescriptor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dwc.ArtifactUploadResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(dwc.ArtifactDescriptor) error); ok {
		r1 = rf(artifactDescriptor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// newSapDwCStageReleaseMockUtils creates a new instance of sapDwCStageReleaseMockUtils. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newSapDwCStageReleaseMockUtils(t interface {
	mock.TestingT
	Cleanup(func())
}) *sapDwCStageReleaseMockUtils {
	mock := &sapDwCStageReleaseMockUtils{}
	mock.Mock.Test(t)
	mock.FilesMock = &piperMocks.FilesMock{}

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

func TestRunSapDwCStageRelease(t *testing.T) {
	t.Parallel()
	type testCase struct {
		name                  string
		prepareReleaseOptions func() *sapDwCStageReleaseOptions
		prepareUtils          func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils
		wantErr               bool
		want                  *sapDwCStageReleaseCommonPipelineEnvironment
	}
	defaultUploadResponse := &dwc.ArtifactUploadResponse{
		ID: "12345-678901234",
	}
	defaultUploadResponse2 := &dwc.ArtifactUploadResponse{
		ID: "67890-123456789",
	}
	tests := []*testCase{
		{
			name: "canonical ui release",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"dist/**"},
					ArtifactType:                    "",            // not relevant for ui releases
					ArtifactURLs:                    nil,           // not relevant for ui releases
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion also not relevant for ui releases
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					OverwriteHelmDockerImage:        false,
					PromotedDockerImage:             "",                              // not relevant for ui releases
					Repository:                      "common.repositories.cloud.sap", // not relevant for ui releases but it is the default
					RequiredSuccessfulStages:        nil,                             // not relevant for chosen stage watch policy
					ResourceName:                    "",                              // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // should default to webapps/<appName>
					UploadType:                      dwc.UploadTypeUI,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						uiDescriptor, ok := artifactDescriptor.(*dwc.UIArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.UIArtifact{}, artifactDescriptor)
						}
						if uiDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, uiDescriptor.DescriptorBase.AppName)
						}
						if uiDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, uiDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, uiDescriptor.DescriptorBase.StagesToWatch)
						}
						if uiDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, uiDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, uiDescriptor.DescriptorBase.FilePatterns)
						}
						if uiDescriptor.UploadBasePath != fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName) {
							t.Errorf("Expected upload base path of artifact descriptor to be %s, but it is %s", fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName), uiDescriptor.UploadBasePath)
						}
						//uploadResponse := defaultUploadResponse
						//uploadResponse.AppName = "myApp"
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical orbit release",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"cf"},
					ArtifactType:                    "",            // not relevant for orbit releases
					ArtifactURLs:                    nil,           // not relevant for orbit releases
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					OverwriteHelmDockerImage:        false,
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap", // not relevant for orbit releases but it is the default
					RequiredSuccessfulStages:        nil,                             // not relevant for chosen stage watch policy
					ResourceName:                    "",                              // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // not relevant for orbit releases
					UploadType:                      dwc.UploadTypeOrbit,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// The container Image URL should be resolved
				utils.On("ResolveContainerImageURL", withOpts.PromotedDockerImage, withOpts.ArtifactVersion).Return(withOpts.PromotedDockerImage, withOpts.ArtifactVersion, nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						orbitDescriptor, ok := artifactDescriptor.(*dwc.OrbitArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.OrbitArtifact{}, artifactDescriptor)
						}
						if orbitDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, orbitDescriptor.DescriptorBase.AppName)
						}
						if orbitDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, orbitDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(orbitDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, orbitDescriptor.DescriptorBase.StagesToWatch)
						}
						if orbitDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, orbitDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(orbitDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, orbitDescriptor.DescriptorBase.FilePatterns)
						}
						if orbitDescriptor.ContainerImageLocator != fmt.Sprintf("%s:%s", withOpts.PromotedDockerImage, withOpts.ArtifactVersion) {
							t.Errorf("Expected ContainerImageLocator of artifact descriptor to be %s, but it is %s", fmt.Sprintf("%s:%s", withOpts.PromotedDockerImage, withOpts.ArtifactVersion), orbitDescriptor.ContainerImageLocator)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical service release that resolves to mta",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"cf"},
					ArtifactType:                    dwc.ArtifactTypeMta,
					ArtifactURLs:                    []string{"my/common.repositories.cloud.sap/url/that_matches.mtar", "random/irrelevant/data"},
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					OverwriteHelmDockerImage:        false,
					PromotedDockerImage:             "", // not relevant for mta services
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "",  // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      dwc.UploadTypeService,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						mtaDescriptor, ok := artifactDescriptor.(*dwc.MTAArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.MTAArtifact{}, artifactDescriptor)
						}
						if mtaDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, mtaDescriptor.DescriptorBase.AppName)
						}
						if mtaDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, mtaDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(mtaDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, mtaDescriptor.DescriptorBase.StagesToWatch)
						}
						if mtaDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, mtaDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(mtaDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, mtaDescriptor.DescriptorBase.FilePatterns)
						}
						if mtaDescriptor.ArtifactURL != "my/common.repositories.cloud.sap/url/that_matches.mtar" {
							t.Errorf("Expected ArtifactURL of artifact descriptor to be %s, but it is %s", "my/common.repositories.cloud.sap/url/that_matches.mtar", mtaDescriptor.ArtifactURL)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical ui release via api gateway",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                  "myApp",
					ArtifactFilesToUpload:    []string{"dist/**"},
					ArtifactType:             "",            // not relevant for ui releases
					ArtifactURLs:             nil,           // not relevant for ui releases
					ArtifactVersion:          "aljkdsldkmb", // influx from artifactPrepareVersion also not relevant for ui releases
					GithubToken:              "paslk",
					HelmChartDirectory:       "helm",
					OverwriteHelmDockerImage: false,
					PromotedDockerImage:      "",                              // not relevant for ui releases
					Repository:               "common.repositories.cloud.sap", // not relevant for ui releases but it is the default
					RequiredSuccessfulStages: nil,                             // not relevant for chosen stage watch policy
					ResourceName:             "",                              // test the auto resolve code path
					StagesToWatch:            []string{"dev/null", "dev/random"},
					StageWatchPolicy:         dwc.StageWatchPolicyOverallSuccess,
					GatewayCertificatePath:   "/etc/ssl/certs",
					UiUploadBasePath:         "", // should default to webapps/<appName>
					UploadType:               dwc.UploadTypeUI,
					WatchResourceOfInterest:  true,
					UploadMetadata:           []string{"foo=bar"},
					GatewayURL:               "https://my.gateway.url",
					ProjectName:              "myProject",
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// descriptor should be of type GatewayLoginDescriptor
						dLDescriptor, ok := loginDescriptor.(dwc.GatewayLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.GatewayLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.GatewayURL != withOpts.GatewayURL {
							t.Errorf("Expected login descriptor to gateway URL %s but it is %s", withOpts.GatewayURL, dLDescriptor.GatewayURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.GatewayCertificatePath {
							t.Errorf("Expected login descriptor to have gateway cert path %s but it is %s", withOpts.GatewayCertificatePath, dLDescriptor.CertificateFilePath)
						}
						if dLDescriptor.Project != withOpts.ProjectName {
							t.Errorf("Expected login descriptor to have project name %s but it is %s", withOpts.ProjectName, dLDescriptor.Project)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						uiDescriptor, ok := artifactDescriptor.(*dwc.UIArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.UIArtifact{}, artifactDescriptor)
						}
						if uiDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, uiDescriptor.DescriptorBase.AppName)
						}
						if uiDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, uiDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, uiDescriptor.DescriptorBase.StagesToWatch)
						}
						if uiDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, uiDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, uiDescriptor.DescriptorBase.FilePatterns)
						}
						if uiDescriptor.UploadBasePath != fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName) {
							t.Errorf("Expected upload base path of artifact descriptor to be %s, but it is %s", fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName), uiDescriptor.UploadBasePath)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				utils.On("DetectOrchestrator").Return(orchestrator.AzureDevOps)
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical ui release using existing dwc cli binary",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                  "myApp",
					ArtifactFilesToUpload:    []string{"dist/**"},
					ArtifactType:             "",            // not relevant for ui releases
					ArtifactURLs:             nil,           // not relevant for ui releases
					ArtifactVersion:          "aljkdsldkmb", // influx from artifactPrepareVersion also not relevant for ui releases
					CliPath:                  "/path/to/dwc/cli",
					GithubToken:              "paslk",
					HelmChartDirectory:       "helm",
					OverwriteHelmDockerImage: false,
					PromotedDockerImage:      "",                              // not relevant for ui releases
					Repository:               "common.repositories.cloud.sap", // not relevant for ui releases but it is the default
					RequiredSuccessfulStages: nil,                             // not relevant for chosen stage watch policy
					ResourceName:             "",                              // test the auto resolve code path
					StagesToWatch:            []string{"dev/null", "dev/random"},
					StageWatchPolicy:         dwc.StageWatchPolicyOverallSuccess,
					GatewayCertificatePath:   "/etc/ssl/certs",
					UiUploadBasePath:         "", // should default to webapps/<appName>
					UploadType:               dwc.UploadTypeUI,
					WatchResourceOfInterest:  true,
					UploadMetadata:           []string{"foo=bar"},
					GatewayURL:               "https://my.gateway.url",
					ProjectName:              "myProject",
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// descriptor should be of type GatewayLoginDescriptor
						dLDescriptor, ok := loginDescriptor.(dwc.GatewayLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.GatewayLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.GatewayURL != withOpts.GatewayURL {
							t.Errorf("Expected login descriptor to gateway URL %s but it is %s", withOpts.GatewayURL, dLDescriptor.GatewayURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.GatewayCertificatePath {
							t.Errorf("Expected login descriptor to have gateway cert path %s but it is %s", withOpts.GatewayCertificatePath, dLDescriptor.CertificateFilePath)
						}
						if dLDescriptor.Project != withOpts.ProjectName {
							t.Errorf("Expected login descriptor to have project name %s but it is %s", withOpts.ProjectName, dLDescriptor.Project)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						uiDescriptor, ok := artifactDescriptor.(*dwc.UIArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.UIArtifact{}, artifactDescriptor)
						}
						if uiDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, uiDescriptor.DescriptorBase.AppName)
						}
						if uiDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, uiDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, uiDescriptor.DescriptorBase.StagesToWatch)
						}
						if uiDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, uiDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, uiDescriptor.DescriptorBase.FilePatterns)
						}
						if uiDescriptor.UploadBasePath != fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName) {
							t.Errorf("Expected upload base path of artifact descriptor to be %s, but it is %s", fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName), uiDescriptor.UploadBasePath)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				utils.On("DetectOrchestrator").Return(orchestrator.AzureDevOps)
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical service release that resolves to helm",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"helm"},
					ArtifactType:                    dwc.ArtifactTypeHelm,
					ArtifactURLs:                    nil,           // irrelevant for helm services
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					OverwriteHelmDockerImage:        true,
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "",  // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      dwc.UploadTypeService,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// The container Image URL should be resolved
				utils.On("ResolveContainerImageURL", withOpts.PromotedDockerImage, withOpts.ArtifactVersion).Return(withOpts.PromotedDockerImage, withOpts.ArtifactVersion, nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						helmDescriptor, ok := artifactDescriptor.(*dwc.HelmArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.HelmArtifact{}, artifactDescriptor)
						}
						if helmDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, helmDescriptor.DescriptorBase.AppName)
						}
						if helmDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, helmDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(helmDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, helmDescriptor.DescriptorBase.StagesToWatch)
						}
						if helmDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, helmDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(helmDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, helmDescriptor.DescriptorBase.FilePatterns)
						}
						if helmDescriptor.PatchImageSpec != withOpts.OverwriteHelmDockerImage {
							t.Errorf("Expected PatchImageSpec of artifact descriptor to be %t, but it is %t", withOpts.OverwriteHelmDockerImage, helmDescriptor.PatchImageSpec)
						}
						if helmDescriptor.ContainerImage != withOpts.PromotedDockerImage {
							t.Errorf("Expected ContainerImage of artifact descriptor to be %s, but it is %s", withOpts.PromotedDockerImage, helmDescriptor.ContainerImage)
						}
						if helmDescriptor.ImageTag != withOpts.ArtifactVersion {
							t.Errorf("Expected ImageTag of artifact descriptor to be %s, but it is %s", withOpts.ArtifactVersion, helmDescriptor.ImageTag)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical service release with multiple app names that resolves to helm",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					Apps:                            []map[string]interface{}{{"name": "myApp1"}, {"name": "myApp2"}},
					ArtifactFilesToUpload:           []string{"helm"},
					ArtifactType:                    dwc.ArtifactTypeHelm,
					ArtifactURLs:                    nil,           // irrelevant for helm services
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					OverwriteHelmDockerImage:        true,
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "",  // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      dwc.UploadTypeService,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// The container Image URL should be resolved
				utils.On("ResolveContainerImageURL", withOpts.PromotedDockerImage, withOpts.ArtifactVersion).Return(withOpts.PromotedDockerImage, withOpts.ArtifactVersion, nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						helmDescriptor, ok := artifactDescriptor.(*dwc.HelmArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.HelmArtifact{}, artifactDescriptor)
						}
						if helmDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, helmDescriptor.DescriptorBase.AppName)
						}
						for i, app := range helmDescriptor.DescriptorBase.Apps {
							if app.Name != withOpts.Apps[i]["name"] {
								t.Errorf("Expected artifact descriptor to have app name %s but it is %s", withOpts.Apps[i]["name"], app.Name)
							}
						}
						if helmDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, helmDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(helmDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, helmDescriptor.DescriptorBase.StagesToWatch)
						}
						if helmDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, helmDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(helmDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, helmDescriptor.DescriptorBase.FilePatterns)
						}
						if helmDescriptor.PatchImageSpec != withOpts.OverwriteHelmDockerImage {
							t.Errorf("Expected PatchImageSpec of artifact descriptor to be %t, but it is %t", withOpts.OverwriteHelmDockerImage, helmDescriptor.PatchImageSpec)
						}
						if helmDescriptor.ContainerImage != withOpts.PromotedDockerImage {
							t.Errorf("Expected ContainerImage of artifact descriptor to be %s, but it is %s", withOpts.PromotedDockerImage, helmDescriptor.ContainerImage)
						}
						if helmDescriptor.ImageTag != withOpts.ArtifactVersion {
							t.Errorf("Expected ImageTag of artifact descriptor to be %s, but it is %s", withOpts.ArtifactVersion, helmDescriptor.ImageTag)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical service release that resolves to helm and uses a custom helm chart directory",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"manifest.yml", ".dwc", "helm", "cf"},
					ArtifactType:                    dwc.ArtifactTypeHelm,
					ArtifactURLs:                    nil,           // irrelevant for helm services
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					HelmChartDirectory:              "chart",
					OverwriteHelmDockerImage:        true,
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "",  // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      dwc.UploadTypeService,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// The container Image URL should be resolved
				utils.On("ResolveContainerImageURL", withOpts.PromotedDockerImage, withOpts.ArtifactVersion).Return(withOpts.PromotedDockerImage, withOpts.ArtifactVersion, nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						helmDescriptor, ok := artifactDescriptor.(*dwc.HelmArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.HelmArtifact{}, artifactDescriptor)
						}
						if helmDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, helmDescriptor.DescriptorBase.AppName)
						}
						if helmDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, helmDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(helmDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, helmDescriptor.DescriptorBase.StagesToWatch)
						}
						if helmDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, helmDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(helmDescriptor.DescriptorBase.FilePatterns, append(withOpts.ArtifactFilesToUpload, withOpts.HelmChartDirectory)) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, helmDescriptor.DescriptorBase.FilePatterns)
						}
						if helmDescriptor.PatchImageSpec != withOpts.OverwriteHelmDockerImage {
							t.Errorf("Expected PatchImageSpec of artifact descriptor to be %t, but it is %t", withOpts.OverwriteHelmDockerImage, helmDescriptor.PatchImageSpec)
						}
						if helmDescriptor.ContainerImage != withOpts.PromotedDockerImage {
							t.Errorf("Expected ContainerImage of artifact descriptor to be %s, but it is %s", withOpts.PromotedDockerImage, helmDescriptor.ContainerImage)
						}
						if helmDescriptor.ImageTag != withOpts.ArtifactVersion {
							t.Errorf("Expected ImageTag of artifact descriptor to be %s, but it is %s", withOpts.ArtifactVersion, helmDescriptor.ImageTag)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical service release with multiple artifacts",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					Artifacts: []map[string]interface{}{
						{
							"uploadType":            dwc.UploadTypeService,
							"artifactType":          dwc.ArtifactTypeHelm,
							"resourceName":          "the-helm-resource",
							"appName":               "myApp1",
							"artifactFilesToUpload": []string{"helm"},
							"hasArchive":            true,
							"promotedDockerImage":   "bp.common.repositories.cloud.sap/dwc-cli",
						}, {
							"uploadType":            dwc.UploadTypeUI,
							"resourceName":          "the-ui-resource",
							"artifactFilesToUpload": []string{"dist"},
							"hasArchive":            true,
							"archivePattern":        "*-ui-*.tgz",
							"uiUploadBasePath":      "webapps/cap-monorepo-poc/",
						}},
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					HelmChartURL:                    "https://some-repo/some-chart.tgz", // influx from helmExecute
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// The helm chart archive should be found in the downloaded archives path
				helmArchiveFileName := filepath.Base(withOpts.HelmChartURL)
				helmChartArchivePath := filepath.Join(withOpts.DownloadedArchivesPath, helmArchiveFileName)
				utils.FilesMock.AddFile(helmChartArchivePath, []byte("content"))
				// The UI artifact archive should be found in the downloaded archives path
				uiArtifactPattern, _ := withOpts.Artifacts[1]["archivePattern"].(string)
				uiArchivePath := filepath.Join(withOpts.DownloadedArchivesPath, uiArtifactPattern)
				utils.FilesMock.AddFile(uiArchivePath, []byte("content"))
				// The archives should be extracted
				utils.On("Untar", helmChartArchivePath, "helm", 1).Return(nil)
				utils.On("Untar", uiArchivePath, "", 1).Return(nil)
				// The container Image URL should be resolved
				utils.On("ResolveContainerImageURL", withOpts.Artifacts[0]["promotedDockerImage"], withOpts.ArtifactVersion).Return(withOpts.Artifacts[0]["promotedDockerImage"], withOpts.ArtifactVersion, nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						artifactConfigs, _ := parseConfigurationInterface[dwc.ArtifactConfiguration](withOpts.Artifacts)
						helmDescriptor, ok := artifactDescriptor.(*dwc.HelmArtifact)
						if ok {
							artifactConfig := artifactConfigs[0]
							if helmDescriptor.DescriptorBase.AppName != artifactConfig.AppName {
								t.Errorf("Expected artifact descriptor to have appname %s but it is %s", artifactConfig.AppName, helmDescriptor.DescriptorBase.AppName)
							}
							if helmDescriptor.DescriptorBase.ResourceName != artifactConfig.ResourceName {
								t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", artifactConfig.ResourceName, helmDescriptor.DescriptorBase.ResourceName)
							}
							if !slices.Equal(helmDescriptor.DescriptorBase.FilePatterns, artifactConfig.ArtifactFilesToUpload) {
								t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", artifactConfig.ArtifactFilesToUpload, helmDescriptor.DescriptorBase.FilePatterns)
							}
							if helmDescriptor.PatchImageSpec != artifactConfig.OverwriteHelmDockerImage {
								t.Errorf("Expected PatchImageSpec of artifact descriptor to be %t, but it is %t", artifactConfig.OverwriteHelmDockerImage, helmDescriptor.PatchImageSpec)
							}
							if helmDescriptor.ContainerImage != artifactConfig.PromotedDockerImage {
								t.Errorf("Expected ContainerImage of artifact descriptor to be %s, but it is %s", artifactConfig.PromotedDockerImage, helmDescriptor.ContainerImage)
							}

							if helmDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
								t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, helmDescriptor.DescriptorBase.WatchROI)
							}
							if !slices.Equal(helmDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
								t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, helmDescriptor.DescriptorBase.StagesToWatch)
							}
							if helmDescriptor.ImageTag != withOpts.ArtifactVersion {
								t.Errorf("Expected ImageTag of artifact descriptor to be %s, but it is %s", withOpts.ArtifactVersion, helmDescriptor.ImageTag)
							}
							return defaultUploadResponse
						} else {
							uiDescriptor, ok := artifactDescriptor.(*dwc.UIArtifact)
							if !ok {
								t.Fatalf("Expected artifact descriptor to be of type %T or %T but it is of type %T", &dwc.HelmArtifact{}, &dwc.UIArtifact{}, artifactDescriptor)
							}
							artifactConfig := artifactConfigs[1]
							if uiDescriptor.DescriptorBase.AppName != artifactConfig.AppName {
								t.Errorf("Expected artifact descriptor to have appname '%s' but it is '%s'", artifactConfig.AppName, uiDescriptor.DescriptorBase.AppName)
							}
							if uiDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
								t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, uiDescriptor.DescriptorBase.WatchROI)
							}
							if !slices.Equal(uiDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
								t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, uiDescriptor.DescriptorBase.StagesToWatch)
							}
							if uiDescriptor.DescriptorBase.ResourceName != artifactConfig.ResourceName {
								t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", artifactConfig.ResourceName, uiDescriptor.DescriptorBase.ResourceName)
							}
							if !slices.Equal(uiDescriptor.DescriptorBase.FilePatterns, artifactConfig.ArtifactFilesToUpload) {
								t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", artifactConfig.ArtifactFilesToUpload, uiDescriptor.DescriptorBase.FilePatterns)
							}
							if uiDescriptor.UploadBasePath != artifactConfig.UiUploadBasePath {
								t.Errorf("Expected artifact descriptor to UI upload base path %s but it is %s", artifactConfig.UiUploadBasePath, uiDescriptor.UploadBasePath)
							}
							return defaultUploadResponse2
						}
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  "",
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID, defaultUploadResponse2.ID},
				},
			},
		},
		{
			name: "canonical ui release via api gateway and GitHub Actions OIDC token authentication against api gateway",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                  "myApp",
					ArtifactFilesToUpload:    []string{"dist/**"},
					ArtifactType:             "",            // not relevant for ui releases
					ArtifactURLs:             nil,           // not relevant for ui releases
					ArtifactVersion:          "aljkdsldkmb", // influx from artifactPrepareVersion also not relevant for ui releases
					GithubToken:              "paslk",
					HelmChartDirectory:       "helm",
					OverwriteHelmDockerImage: false,
					PromotedDockerImage:      "",                              // not relevant for ui releases
					Repository:               "common.repositories.cloud.sap", // not relevant for ui releases but it is the default
					RequiredSuccessfulStages: nil,                             // not relevant for chosen stage watch policy
					ResourceName:             "",                              // test the auto resolve code path
					StagesToWatch:            []string{"dev/null", "dev/random"},
					StageWatchPolicy:         dwc.StageWatchPolicyOverallSuccess,
					GatewayCertificatePath:   "/etc/ssl/certs",
					UiUploadBasePath:         "", // should default to webapps/<appName>
					UploadType:               dwc.UploadTypeUI,
					WatchResourceOfInterest:  true,
					UploadMetadata:           []string{"foo=bar"},
					GatewayURL:               dwc.DefaultMtlsGatewayUrl, // test overriding the default gateway URL
					ProjectName:              "myProject",
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				// The OIDC token should be resolved from the environment
				utils.On("LookupEnv", dwc.GitHubActionsOIDCTokenRequestTokenEnvVar).Return("the-token", true)
				utils.On("LookupEnv", dwc.GitHubActionsOIDCTokenRequestURLEnvVar).Return("https://the-issuer.url", true)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// descriptor should be of type GatewayLoginDescriptor
						dLDescriptor, ok := loginDescriptor.(dwc.GatewayLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.GatewayLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.GatewayURL != dwc.DefaultGatewayUrl {
							t.Errorf("Expected login descriptor to gateway URL %s but it is %s", dwc.DefaultGatewayUrl, dLDescriptor.GatewayURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.GatewayCertificatePath {
							t.Errorf("Expected login descriptor to have gateway cert path %s but it is %s", withOpts.GatewayCertificatePath, dLDescriptor.CertificateFilePath)
						}
						if dLDescriptor.Project != withOpts.ProjectName {
							t.Errorf("Expected login descriptor to have project name %s but it is %s", withOpts.ProjectName, dLDescriptor.Project)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						uiDescriptor, ok := artifactDescriptor.(*dwc.UIArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.UIArtifact{}, artifactDescriptor)
						}
						if uiDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, uiDescriptor.DescriptorBase.AppName)
						}
						if uiDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, uiDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, uiDescriptor.DescriptorBase.StagesToWatch)
						}
						if uiDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, uiDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(uiDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, uiDescriptor.DescriptorBase.FilePatterns)
						}
						if uiDescriptor.UploadBasePath != fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName) {
							t.Errorf("Expected upload base path of artifact descriptor to be %s, but it is %s", fmt.Sprintf("webapps/%s/", uiDescriptor.DescriptorBase.AppName), uiDescriptor.UploadBasePath)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				utils.On("DetectOrchestrator").Return(orchestrator.GitHubActions)
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "canonical service release with multiple artifacts and UI extracted from MTA",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					Artifacts: []map[string]interface{}{
						{
							"uploadType":   dwc.UploadTypeService,
							"artifactType": dwc.ArtifactTypeMta,
							"repository":   "common.repositories.cloud.sap",
							"resourceName": "the-mta-resource",
							"appName":      "myApp1",
						}, {
							"uploadType":            dwc.UploadTypeUI,
							"resourceName":          "the-ui-resource",
							"appName":               "myApp2",
							"artifactFilesToUpload": []string{"dist"},
							"extractFromMTA":        true,
						}},
					ArtifactURLs:             []string{"my/common.repositories.cloud.sap/url/that_matches.mtar", "random/irrelevant/data"},
					ArtifactVersion:          "aljkdsldkmb", // influx from artifactPrepareVersion
					DownloadedArchivesPath:   "promotedAndDownloaded",
					GatewayCertificatePath:   "/etc/ssl/certs",
					GatewayURL:               "https://my.gateway.url",
					GithubToken:              "paslk",
					HelmChartDirectory:       "helm",
					MtarFilePath:             "some-mta.mtar", // influx from mtaBuild
					MtarUIPath:               "ui",
					ProjectName:              "myProject",
					RequiredSuccessfulStages: nil, // not relevant for chosen stage watch policy
					StagesToWatch:            []string{"dev/null", "dev/random"},
					StageWatchPolicy:         dwc.StageWatchPolicyOverallSuccess,
					WatchResourceOfInterest:  true,
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				artifactConfigs, _ := parseConfigurationInterface[dwc.ArtifactConfiguration](withOpts.Artifacts)
				mtarArchivePath := filepath.Join(withOpts.DownloadedArchivesPath, withOpts.MtarFilePath)
				uiBundleArchivePath := filepath.Join(mtarExtractionDestination, dwcUIAppContentModule, withOpts.MtarUIPath, "data.zip")
				uiArtifactArchivePath := filepath.Join(withOpts.DownloadedArchivesPath, fmt.Sprintf("%s.zip", artifactConfigs[1].AppName))

				utils := newSapDwCStageReleaseMockUtils(t)
				// The mtar archive should be found in the downloaded archives path
				utils.FilesMock.AddFile(mtarArchivePath, []byte("content"))
				// The mtar archive should be extracted
				utils.On("Unzip", mtarArchivePath, mtarExtractionDestination).Return(func() error {
					// The archive from within the mtar archive bundling all UI resources should be found in the extracted mtar path
					utils.FilesMock.AddFile(uiBundleArchivePath, []byte("content"))
					return nil
				}())
				// The archive from within the mtar archive bundling all UI resources should be extracted
				utils.On("Unzip", uiBundleArchivePath, withOpts.DownloadedArchivesPath).Return(func() error {
					// The UI artifact archive should be found in the downloaded archives path
					utils.FilesMock.AddFile(uiArtifactArchivePath, []byte("content"))
					return nil
				}())
				// The UI artifact archive should be extracted
				utils.On("Unzip", uiArtifactArchivePath, "dist").Return(nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// descriptor should be of type GatewayLoginDescriptor
						dLDescriptor, ok := loginDescriptor.(dwc.GatewayLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.GatewayLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.GatewayURL != withOpts.GatewayURL {
							t.Errorf("Expected login descriptor to gateway URL %s but it is %s", withOpts.GatewayURL, dLDescriptor.GatewayURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.GatewayCertificatePath {
							t.Errorf("Expected login descriptor to have gateway cert path %s but it is %s", withOpts.GatewayCertificatePath, dLDescriptor.CertificateFilePath)
						}
						if dLDescriptor.Project != withOpts.ProjectName {
							t.Errorf("Expected login descriptor to have project name %s but it is %s", withOpts.ProjectName, dLDescriptor.Project)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						mtaDescriptor, ok := artifactDescriptor.(*dwc.MTAArtifact)
						if ok {
							artifactConfig := artifactConfigs[0]
							if mtaDescriptor.DescriptorBase.AppName != artifactConfig.AppName {
								t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, mtaDescriptor.DescriptorBase.AppName)
							}
							if mtaDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
								t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, mtaDescriptor.DescriptorBase.WatchROI)
							}
							if !slices.Equal(mtaDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
								t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, mtaDescriptor.DescriptorBase.StagesToWatch)
							}
							if mtaDescriptor.DescriptorBase.ResourceName != artifactConfig.ResourceName {
								t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, mtaDescriptor.DescriptorBase.ResourceName)
							}
							if !slices.Equal(mtaDescriptor.DescriptorBase.FilePatterns, artifactConfig.ArtifactFilesToUpload) {
								t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, mtaDescriptor.DescriptorBase.FilePatterns)
							}
							if mtaDescriptor.ArtifactURL != "my/common.repositories.cloud.sap/url/that_matches.mtar" {
								t.Errorf("Expected ArtifactURL of artifact descriptor to be %s, but it is %s", "my/common.repositories.cloud.sap/url/that_matches.mtar", mtaDescriptor.ArtifactURL)
							}
							return defaultUploadResponse
						} else {
							uiDescriptor, ok := artifactDescriptor.(*dwc.UIArtifact)
							if !ok {
								t.Fatalf("Expected artifact descriptor to be of type %T or %T but it is of type %T", &dwc.HelmArtifact{}, &dwc.UIArtifact{}, artifactDescriptor)
							}
							artifactConfig := artifactConfigs[1]
							if uiDescriptor.DescriptorBase.AppName != artifactConfig.AppName {
								t.Errorf("Expected artifact descriptor to have appname '%s' but it is '%s'", artifactConfig.AppName, uiDescriptor.DescriptorBase.AppName)
							}
							if uiDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
								t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, uiDescriptor.DescriptorBase.WatchROI)
							}
							if !slices.Equal(uiDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
								t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, uiDescriptor.DescriptorBase.StagesToWatch)
							}
							if uiDescriptor.DescriptorBase.ResourceName != artifactConfig.ResourceName {
								t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", artifactConfig.ResourceName, uiDescriptor.DescriptorBase.ResourceName)
							}
							if !slices.Equal(uiDescriptor.DescriptorBase.FilePatterns, artifactConfig.ArtifactFilesToUpload) {
								t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", artifactConfig.ArtifactFilesToUpload, uiDescriptor.DescriptorBase.FilePatterns)
							}
							if uiDescriptor.UploadBasePath != "webapps/myApp2/" {
								t.Errorf("Expected artifact descriptor to UI upload base path 'webapps/myApp2/' but it is %s", uiDescriptor.UploadBasePath)
							}
							return defaultUploadResponse2
						}
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				utils.On("DetectOrchestrator").Return(orchestrator.AzureDevOps)
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  "",
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID, defaultUploadResponse2.ID},
				},
			},
		},
		{
			name: "canonical service release that resolves to docker and sets additional download URLs",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"cf"},
					ArtifactType:          dwc.ArtifactTypeDocker,
					ArtifactURLs:          nil,           // not relevant for docker services
					ArtifactVersion:       "aljkdsldkmb", // influx from artifactPrepareVersion
					DeriveAdditionalDownloadURLs: []map[string]interface{}{
						{
							"key":         "cn20",
							"findPattern": "common\\.repositories\\.cloud\\.sap",
							"replaceWith": "common.repositories.sapcloud.cn",
						},
					},
					GithubToken:                     "paslk",
					HelmChartDirectory:              "helm",
					OverwriteHelmDockerImage:        false,
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "",  // test the auto resolve code path
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					ThemistoInstanceURL:             "https://themisto-dwc-trial.cfapps.eu10.hana.ondemand.com/",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      dwc.UploadTypeService,
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// Since the resource name is not set the default value should be resolved
				utils.On("ResolveDefaultResourceName", utils).Return("https://github.tools.sap/deploy-with-confidence/sponde/main", nil)
				utils.On("ResolveContainerImageURL", withOpts.PromotedDockerImage, withOpts.ArtifactVersion).Return(withOpts.PromotedDockerImage, withOpts.ArtifactVersion, nil)
				// DwC CLI should be installed with the provided token
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				// validate the generated descriptor passed for login
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// should resolve to themisto descriptor
						dLDescriptor, ok := loginDescriptor.(dwc.ThemistoLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.ThemistoLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.ThemistoURL != withOpts.ThemistoInstanceURL {
							t.Errorf("Expected login descriptor to have themisto URL %s but it is %s", withOpts.ThemistoInstanceURL, dLDescriptor.ThemistoURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.ThemistoInstanceCertificatePath {
							t.Errorf("Expected login descriptor to have cert path %s but it is %s", withOpts.ThemistoInstanceCertificatePath, dLDescriptor.CertificateFilePath)
						}
						return nil
					})
				// next validate the generated descriptor passed for upload
				utils.On("UploadArtifact", mock.Anything).Return(
					func(artifactDescriptor dwc.ArtifactDescriptor) *dwc.ArtifactUploadResponse {
						dockerDescriptor, ok := artifactDescriptor.(*dwc.DockerArtifact)
						if !ok {
							t.Fatalf("Expected artifact descriptor to be of type %T but it is of type %T", &dwc.DockerArtifact{}, artifactDescriptor)
						}
						if dockerDescriptor.DescriptorBase.AppName != withOpts.AppName {
							t.Errorf("Expected artifact descriptor to have appname %s but it is %s", withOpts.AppName, dockerDescriptor.DescriptorBase.AppName)
						}
						if dockerDescriptor.DescriptorBase.WatchROI != withOpts.WatchResourceOfInterest {
							t.Errorf("Expected artifact descriptor to have ROI setting %t but it is %t", withOpts.WatchResourceOfInterest, dockerDescriptor.DescriptorBase.WatchROI)
						}
						if !slices.Equal(dockerDescriptor.DescriptorBase.StagesToWatch, withOpts.StagesToWatch) {
							t.Errorf("Expected artifact descriptor to have StagesToWatch setting %v but it is %v", withOpts.StagesToWatch, dockerDescriptor.DescriptorBase.StagesToWatch)
						}
						if dockerDescriptor.DescriptorBase.ResourceName != withOpts.ResourceName {
							t.Errorf("Expected artifact descriptor to have resource name %s but it is %s", withOpts.ResourceName, dockerDescriptor.DescriptorBase.ResourceName)
						}
						if !slices.Equal(dockerDescriptor.DescriptorBase.FilePatterns, withOpts.ArtifactFilesToUpload) {
							t.Errorf("Expected artifact descriptor to have file patterns %v, but they are %v", withOpts.ArtifactFilesToUpload, dockerDescriptor.DescriptorBase.FilePatterns)
						}
						if dockerDescriptor.ContainerImageLocator != "bp.common.repositories.cloud.sap/dwc-cli:aljkdsldkmb" {
							t.Errorf("Expected ContainerImageLocator of artifact descriptor to be %s, but it is %s", "bp.common.repositories.cloud.sap/dwc-cli:aljkdsldkmb", dockerDescriptor.ContainerImageLocator)
						}
						if len(dockerDescriptor.AdditionalDownloadURLs) != 1 || dockerDescriptor.AdditionalDownloadURLs["cn20"] != "bp.common.repositories.sapcloud.cn/dwc-cli:aljkdsldkmb" {
							t.Errorf("Expected AdditionalDownloadURLs of artifact descriptor to have exactly 1 entry with key '%s' and value '%s', but it is %v", "cn20", "bp.common.repositories.sapcloud.cn/dwc-cli:aljkdsldkmb", dockerDescriptor.AdditionalDownloadURLs)
						}
						return defaultUploadResponse
					},
					func(artifactDescriptor dwc.ArtifactDescriptor) error {
						return nil
					})
				return utils
			},
			wantErr: false,
			want: &sapDwCStageReleaseCommonPipelineEnvironment{
				custom: struct {
					dwcUploadedArtifactID  string
					dwcUploadedArtifactIDs []string
				}{
					dwcUploadedArtifactID:  defaultUploadResponse.ID,
					dwcUploadedArtifactIDs: []string{defaultUploadResponse.ID},
				},
			},
		},
		{
			name: "missing mandatory parameter implies step failure",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"helm"},
					ArtifactType:                    dwc.ArtifactTypeHelm,
					ArtifactURLs:                    nil,           // irrelevant for helm services
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GithubToken:                     "paslk",
					OverwriteHelmDockerImage:        true,
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "myResource",
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      "", // MANDATORY but not set -> should return an error -> run should fail -> test should be successful
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foo=bar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				// parameters should be checked first. Any invoke on the utils will fail the test. The release should short circuit in that case.
				return newSapDwCStageReleaseMockUtils(t)
			},
			wantErr: true,
			want:    &sapDwCStageReleaseCommonPipelineEnvironment{},
		},
		{
			name: "failure during parsing of upload metadata",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                         "myApp",
					ArtifactFilesToUpload:           []string{"helm"},
					ArtifactType:                    dwc.ArtifactTypeHelm,
					ArtifactURLs:                    nil,           // irrelevant for helm services
					ArtifactVersion:                 "aljkdsldkmb", // influx from artifactPrepareVersion
					GatewayURL:                      "https://ganymede",
					GatewayCertificatePath:          "certs",
					GithubToken:                     "paslk",
					OverwriteHelmDockerImage:        true,
					ProjectName:                     "myProject",
					PromotedDockerImage:             "bp.common.repositories.cloud.sap/dwc-cli",
					Repository:                      "common.repositories.cloud.sap",
					RequiredSuccessfulStages:        nil, // not relevant for chosen stage watch policy
					ResourceName:                    "myResource",
					StagesToWatch:                   []string{"dev/null", "dev/random"},
					StageWatchPolicy:                dwc.StageWatchPolicyOverallSuccess,
					ThemistoInstanceCertificatePath: "/etc/ssl/certs",
					UiUploadBasePath:                "", // not relevant for service releases
					UploadType:                      "service",
					WatchResourceOfInterest:         true,
					UploadMetadata:                  []string{"foobar"},
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				// DwC CLI should be installed with the provided token
				utils.On("DetectOrchestrator").Return(orchestrator.AzureDevOps)
				utils.On("InstallDwCCli", withOpts.GithubToken).Return(nil)
				utils.On("LoginToDwCCli", mock.Anything).Return(
					func(loginDescriptor dwc.LoginDescriptor) error {
						// descriptor should be of type GatewayLoginDescriptor
						dLDescriptor, ok := loginDescriptor.(dwc.GatewayLoginDescriptor)
						if !ok {
							t.Fatalf("Expected login descriptor to be of type %T but it is of type %T", dwc.GatewayLoginDescriptor{}, loginDescriptor)
						}
						if dLDescriptor.GatewayURL != withOpts.GatewayURL {
							t.Errorf("Expected login descriptor to gateway URL %s but it is %s", withOpts.GatewayURL, dLDescriptor.GatewayURL)
						}
						if dLDescriptor.CertificateFilePath != withOpts.GatewayCertificatePath {
							t.Errorf("Expected login descriptor to have gateway cert path %s but it is %s", withOpts.GatewayCertificatePath, dLDescriptor.CertificateFilePath)
						}
						if dLDescriptor.Project != withOpts.ProjectName {
							t.Errorf("Expected login descriptor to have project name %s but it is %s", withOpts.ProjectName, dLDescriptor.Project)
						}
						return nil
					})
				return utils
			},
			wantErr: true,
			want:    &sapDwCStageReleaseCommonPipelineEnvironment{},
		},
		{
			name: "missing environment variable PIPER_ACTIONS_ID_TOKEN_REQUEST_TOKEN implies step failure",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                  "myApp",
					ArtifactFilesToUpload:    []string{"dist/**"},
					ArtifactType:             "",            // not relevant for ui releases
					ArtifactURLs:             nil,           // not relevant for ui releases
					ArtifactVersion:          "aljkdsldkmb", // influx from artifactPrepareVersion also not relevant for ui releases
					GithubToken:              "paslk",
					OverwriteHelmDockerImage: false,
					PromotedDockerImage:      "",                              // not relevant for ui releases
					Repository:               "common.repositories.cloud.sap", // not relevant for ui releases but it is the default
					RequiredSuccessfulStages: nil,                             // not relevant for chosen stage watch policy
					ResourceName:             "myResource",
					StagesToWatch:            []string{"dev/null", "dev/random"},
					StageWatchPolicy:         dwc.StageWatchPolicyOverallSuccess,
					GatewayCertificatePath:   "/etc/ssl/certs",
					UiUploadBasePath:         "", // should default to webapps/<appName>
					UploadType:               dwc.UploadTypeUI,
					WatchResourceOfInterest:  true,
					UploadMetadata:           []string{"foo=bar"},
					GatewayURL:               "https://my.gateway.url",
					ProjectName:              "myProject",
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.On("DetectOrchestrator").Return(orchestrator.GitHubActions)
				utils.On("LookupEnv", dwc.GitHubActionsOIDCTokenRequestTokenEnvVar).Return("", false)
				return utils
			},
			wantErr: true,
			want:    &sapDwCStageReleaseCommonPipelineEnvironment{},
		},
		{
			name: "missing environment variable PIPER_ACTIONS_ID_TOKEN_REQUEST_URL implies step failure",
			prepareReleaseOptions: func() *sapDwCStageReleaseOptions {
				return &sapDwCStageReleaseOptions{
					AppName:                  "myApp",
					ArtifactFilesToUpload:    []string{"dist/**"},
					ArtifactType:             "",            // not relevant for ui releases
					ArtifactURLs:             nil,           // not relevant for ui releases
					ArtifactVersion:          "aljkdsldkmb", // influx from artifactPrepareVersion also not relevant for ui releases
					GithubToken:              "paslk",
					OverwriteHelmDockerImage: false,
					PromotedDockerImage:      "",                              // not relevant for ui releases
					Repository:               "common.repositories.cloud.sap", // not relevant for ui releases but it is the default
					RequiredSuccessfulStages: nil,                             // not relevant for chosen stage watch policy
					ResourceName:             "myResource",
					StagesToWatch:            []string{"dev/null", "dev/random"},
					StageWatchPolicy:         dwc.StageWatchPolicyOverallSuccess,
					GatewayCertificatePath:   "/etc/ssl/certs",
					UiUploadBasePath:         "", // should default to webapps/<appName>
					UploadType:               dwc.UploadTypeUI,
					WatchResourceOfInterest:  true,
					UploadMetadata:           []string{"foo=bar"},
					GatewayURL:               "https://my.gateway.url",
					ProjectName:              "myProject",
				}
			},
			prepareUtils: func(t *testing.T, withOpts *sapDwCStageReleaseOptions) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.On("DetectOrchestrator").Return(orchestrator.GitHubActions)
				utils.On("LookupEnv", dwc.GitHubActionsOIDCTokenRequestTokenEnvVar).Return("the-token", true)
				utils.On("LookupEnv", dwc.GitHubActionsOIDCTokenRequestURLEnvVar).Return("", false)
				return utils
			},
			wantErr: true,
			want:    &sapDwCStageReleaseCommonPipelineEnvironment{},
		},
	}
	for _, c := range tests {
		testCase := c
		t.Run(testCase.name, func(t *testing.T) {
			t.Parallel()
			opts := testCase.prepareReleaseOptions()
			utils := testCase.prepareUtils(t, opts)
			cpe := &sapDwCStageReleaseCommonPipelineEnvironment{}
			err := runSapDwCStageRelease(opts, nil, cpe, utils)
			if (err != nil) != testCase.wantErr {
				t.Fatalf("runSapDwCStageRelease() error = %v, wantErr %v", err, testCase.wantErr)
			}
			assert.Equal(t, testCase.want, cpe)
		})
	}
}

func Test_parseUploadMetadata(t *testing.T) {
	t.Parallel()
	type args struct {
		metadata []string
	}
	type testCase struct {
		name    string
		args    args
		want    map[string]string
		wantErr bool
	}
	tests := []testCase{
		{
			name: "valid input",
			args: args{
				metadata: []string{"foo=bar", "codeOwner=fritz"},
			},
			want:    map[string]string{"foo": "bar", "codeOwner": "fritz"},
			wantErr: false,
		},
		{
			name: "invalid input (without '=')",
			args: args{
				metadata: []string{"foobar"},
			},
			want:    nil,
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got, err := parseUploadMetadata(test.args.metadata)
			if (err != nil) != test.wantErr {
				t.Fatalf("parseUploadMetadata() error = %v, wantErr %v", err, test.wantErr)
			}
			assert.Equalf(t, test.want, got, "parseUploadMetadata(%v)", test.args.metadata)
		})
	}
}

func Test_validateAppNameProvidedExactlyOnce(t *testing.T) {
	t.Parallel()
	type args struct {
		config *sapDwCStageReleaseOptions
	}
	type testCase struct {
		name string
		args args
		want error
	}
	tests := []testCase{
		{
			name: "app name provided via appName property",
			args: args{
				config: &sapDwCStageReleaseOptions{
					AppName: "myApp",
				},
			},
			want: nil,
		},
		{
			name: "app name provided via apps property",
			args: args{
				config: &sapDwCStageReleaseOptions{
					Apps: []map[string]interface{}{map[string]interface{}{"name": "myApp"}},
				},
			},
			want: nil,
		},
		{
			name: "app name not provided",
			args: args{
				config: &sapDwCStageReleaseOptions{
					AppName: "",
					Apps:    []map[string]interface{}{},
				},
			},
			want: fmt.Errorf("neither parameter appName nor apps is set, however, providing one of them is mandatory"),
		},
		{
			name: "app name provided twice",
			args: args{
				config: &sapDwCStageReleaseOptions{
					AppName: "myApp",
					Apps:    []map[string]interface{}{map[string]interface{}{"name": "myApp"}},
				},
			},
			want: fmt.Errorf("both parameters appName and apps are set, however, only one of them can be provided"),
		},
		{
			name: "apps entry without name",
			args: args{
				config: &sapDwCStageReleaseOptions{
					AppName: "",
					Apps:    []map[string]interface{}{{"noEuporieTaskCollection": true}},
				},
			},
			want: fmt.Errorf("name is not set for at least one app in config list"),
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got := validateAppNameProvidedExactlyOnceAndUnique(test.args.config.AppName, test.args.config.Apps)
			assert.Equalf(t, test.want, got, "validateAppNameProvidedExactlyOnceAndUnique(%v)", test.args.config)
		})
	}
}

func Test_parseConfigurationInterfaceForApps(t *testing.T) {
	t.Parallel()
	type args struct {
		appsConfig []map[string]interface{}
	}
	type testCase struct {
		name string
		args args
		want []dwc.App
	}
	tests := []testCase{
		{
			name: "empty input",
			args: args{
				appsConfig: []map[string]interface{}{},
			},
			want: []dwc.App{},
		},
		{
			name: "single app",
			args: args{
				appsConfig: []map[string]interface{}{map[string]interface{}{"name": "myApp"}},
			},
			want: []dwc.App{dwc.App{Name: "myApp"}},
		},
		{
			name: "multiple apps",
			args: args{
				appsConfig: []map[string]interface{}{
					map[string]interface{}{"name": "myApp1"},
					map[string]interface{}{"name": "myApp2"},
				},
			},
			want: []dwc.App{dwc.App{Name: "myApp1"}, dwc.App{Name: "myApp2"}},
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got, _ := parseConfigurationInterface[dwc.App](test.args.appsConfig)
			assert.Equalf(t, test.want, got, "parseConfigurationInterface(%v)", test.args.appsConfig)
		})
	}
}

func Test_parseConfigurationInterfaceForArtifacts(t *testing.T) {
	t.Parallel()
	type args struct {
		artifactsConfig []map[string]interface{}
	}
	type testCase struct {
		name string
		args args
		want []dwc.ArtifactConfiguration
	}
	tests := []testCase{
		{
			name: "empty input",
			args: args{
				artifactsConfig: []map[string]interface{}{},
			},
			want: []dwc.ArtifactConfiguration{},
		},
		{
			name: "single artifact",
			args: args{
				artifactsConfig: []map[string]interface{}{map[string]interface{}{"appName": "myApp"}},
			},
			want: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{AppName: "myApp"}},
		},
		{
			name: "multiple artifacts",
			args: args{
				artifactsConfig: []map[string]interface{}{
					map[string]interface{}{"appName": "myApp1"},
					map[string]interface{}{"appName": "myApp2"},
				},
			},
			want: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{AppName: "myApp1"}, dwc.ArtifactConfiguration{AppName: "myApp2"}},
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got, _ := parseConfigurationInterface[dwc.ArtifactConfiguration](test.args.artifactsConfig)
			assert.Equalf(t, test.want, got, "parseConfigurationInterface(%v)", test.args.artifactsConfig)
		})
	}
}

func Test_parseConfigurationInterfaceForDeriveAdditionalDownloadURLsEntry(t *testing.T) {
	t.Parallel()
	type args struct {
		deriveAdditionalDownloadURLsConfig []map[string]interface{}
	}
	type testCase struct {
		name string
		args args
		want []dwc.DeriveAdditionalDownloadURLsEntry
	}
	tests := []testCase{
		{
			name: "empty input",
			args: args{
				deriveAdditionalDownloadURLsConfig: []map[string]interface{}{},
			},
			want: []dwc.DeriveAdditionalDownloadURLsEntry{},
		},
		{
			name: "single entry",
			args: args{
				deriveAdditionalDownloadURLsConfig: []map[string]interface{}{{
					"key":         "cn20",
					"findPattern": "common\\.repositories\\.cloud\\.sap",
					"replaceWith": "common.repositories.sapcloud.cn",
				}},
			},
			want: []dwc.DeriveAdditionalDownloadURLsEntry{{
				Key:         "cn20",
				FindPattern: "common\\.repositories\\.cloud\\.sap",
				ReplaceWith: "common.repositories.sapcloud.cn",
			}},
		},
		{
			name: "multiple entries",
			args: args{
				deriveAdditionalDownloadURLsConfig: []map[string]interface{}{
					{
						"key":         "cn20",
						"findPattern": "common\\.repositories\\.cloud\\.sap",
						"replaceWith": "common.repositories.sapcloud.cn",
					},
					{
						"key":         "ap10",
						"findPattern": "(common\\.repositories)\\.cloud\\.sap",
						"replaceWith": "$1.sapcloud.ap",
					},
				},
			},
			want: []dwc.DeriveAdditionalDownloadURLsEntry{
				{
					Key:         "cn20",
					FindPattern: "common\\.repositories\\.cloud\\.sap",
					ReplaceWith: "common.repositories.sapcloud.cn",
				},
				{
					Key:         "ap10",
					FindPattern: "(common\\.repositories)\\.cloud\\.sap",
					ReplaceWith: "$1.sapcloud.ap",
				},
			},
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got, _ := parseConfigurationInterface[dwc.DeriveAdditionalDownloadURLsEntry](test.args.deriveAdditionalDownloadURLsConfig)
			assert.Equalf(t, test.want, got, "parseConfigurationInterface(%v)", test.args.deriveAdditionalDownloadURLsConfig)
		})
	}
}

func Test_validateArtifactConfigurations(t *testing.T) {
	t.Parallel()
	type args struct {
		artifacts []dwc.ArtifactConfiguration
	}
	type testCase struct {
		name    string
		args    args
		wantErr bool
	}
	tests := []testCase{
		{
			name: "valid input",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "service",
					ArtifactType:          "helm",
					ResourceName:          "myResource",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: false,
		},
		{
			name: "invalid upload type",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "invalid",
					ArtifactType:          "helm",
					ResourceName:          "myResource",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: true,
		},
		{
			name: "invalid artifact type",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "service",
					ArtifactType:          "invalid",
					ResourceName:          "myResource",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: true,
		},
		{
			name: "missing resource name",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "service",
					ArtifactType:          "helm",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: true,
		},
		{
			name: "missing app name",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "service",
					ArtifactType:          "helm",
					ResourceName:          "myResource",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: true,
		},
		{
			name: "missing artifactFilesToUpload",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:   "service",
					ArtifactType: "helm",
					ResourceName: "myResource",
					AppName:      "myApp",
				}},
			},
			wantErr: true,
		},
		{
			name: "ArtifactConfiguration that defines multiple app names",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "service",
					ArtifactType:          "helm",
					ResourceName:          "myResource",
					ArtifactFilesToUpload: []string{"helm"},
					Apps: []map[string]interface{}{
						map[string]interface{}{"name": "myApp1"},
						map[string]interface{}{"name": "myApp2"},
					},
				}},
			},
			wantErr: false,
		},
		{
			name: "Artifacts that define equal resource names",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{
					{
						UploadType:            "service",
						ArtifactType:          "helm",
						ResourceName:          "myResource",
						ArtifactFilesToUpload: []string{"helm"},
						AppName:               "myApp1",
					},
					{
						UploadType:            "service",
						ArtifactType:          "helm",
						ResourceName:          "myResource",
						ArtifactFilesToUpload: []string{"helm2"},
						AppName:               "myApp2",
					}},
			},
			wantErr: true,
		},
		{
			name: "invalid combination of artifact type and upload type UI",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "ui",
					ArtifactType:          "mta",
					ResourceName:          "myResource",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: true,
		},
		{
			name: "invalid combination of artifact type and upload type orbit",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "orbit",
					ArtifactType:          "mta",
					ResourceName:          "myResource",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: true,
		},
		{
			name: "valid combination of artifact type and upload type orbit",
			args: args{
				artifacts: []dwc.ArtifactConfiguration{dwc.ArtifactConfiguration{
					UploadType:            "orbit",
					ArtifactType:          "dockerbuild-releaseMetadata",
					ResourceName:          "myResource",
					AppName:               "myApp",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			err := validateArtifactConfigurations(test.args.artifacts)
			if (err != nil) != test.wantErr {
				t.Fatalf("validateArtifactConfigurations() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_validateConfigurations(t *testing.T) {
	t.Parallel()
	type args struct {
		globalConfiguration    dwc.GlobalConfiguration
		artifactConfigurations []dwc.ArtifactConfiguration
	}
	type testCase struct {
		name    string
		args    args
		wantErr bool
	}
	tests := []testCase{
		{
			name: "use valid configurations",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					ThemistoInstanceURL: "https://themisto.url",
				},
				artifactConfigurations: []dwc.ArtifactConfiguration{{
					UploadType:            dwc.UploadTypeService,
					ArtifactType:          dwc.ArtifactTypeMaven,
					ResourceName:          "myResource",
					AppName:               "appName",
					ArtifactFilesToUpload: []string{"file1", "file2"},
				}},
			},
			wantErr: false,
		},
		{
			name: "don't provide app name",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					ThemistoInstanceURL: "https://themisto.url",
				},
				artifactConfigurations: []dwc.ArtifactConfiguration{{
					UploadType: dwc.UploadTypeService,
				}},
			},
			wantErr: true,
		},
		{
			name: "provide non-unique app names",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					ThemistoInstanceURL: "https://themisto.url",
				},
				artifactConfigurations: []dwc.ArtifactConfiguration{{
					UploadType: dwc.UploadTypeService,
					Apps: []map[string]interface{}{
						map[string]interface{}{"name": "myApp1"},
						map[string]interface{}{"name": "myApp1"},
					},
				}},
			},
			wantErr: true,
		},
		{
			name: "use valid artifact configuration",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					ThemistoInstanceURL: "https://themisto.url",
				},
				artifactConfigurations: []dwc.ArtifactConfiguration{{
					UploadType:            dwc.UploadTypeService,
					AppName:               "myApp",
					ArtifactType:          dwc.ArtifactTypeHelm,
					ResourceName:          "myResource",
					ArtifactFilesToUpload: []string{"helm"},
				}},
			},
			wantErr: false,
		},
		{
			name: "use invalid artifact configuration",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					ThemistoInstanceURL: "https://themisto.url",
				},
				artifactConfigurations: []dwc.ArtifactConfiguration{{
					UploadType: dwc.UploadTypeService,
				}},
			},
			wantErr: true,
		},
		{
			name: "provide non-unique resource names",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					ThemistoInstanceURL: "https://themisto.url",
				},
				artifactConfigurations: []dwc.ArtifactConfiguration{
					{
						UploadType:            dwc.UploadTypeService,
						ArtifactType:          dwc.ArtifactTypeMaven,
						ResourceName:          "myResource",
						AppName:               "appName1",
						ArtifactFilesToUpload: []string{"file1", "file2"},
					},
					{
						UploadType:            dwc.UploadTypeService,
						ArtifactType:          dwc.ArtifactTypeMaven,
						ResourceName:          "myResource",
						AppName:               "appName2",
						ArtifactFilesToUpload: []string{"file1", "file2"},
					},
				},
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			err := validateConfigurations(test.args.globalConfiguration, test.args.artifactConfigurations)
			if (err != nil) != test.wantErr {
				t.Fatalf("validateConfigurations() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_extractArchive(t *testing.T) {
	t.Parallel()
	type args struct {
		archivePath     string
		targetPath      string
		extractionLevel int
	}
	type testCase struct {
		name         string
		args         args
		prepareUtils func(t *testing.T, withArgs args) sapDwCStageReleaseUtils
		wantErr      bool
	}
	tests := []testCase{
		{
			name: "successful extraction of tgz archive",
			args: args{
				archivePath:     "archive.tgz",
				targetPath:      "target",
				extractionLevel: 1,
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.AddFile(withArgs.archivePath, []byte("content"))
				utils.On("Untar", withArgs.archivePath, withArgs.targetPath, withArgs.extractionLevel).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "error while checking if archive exists",
			args: args{
				archivePath:     "archive.tgz",
				targetPath:      "target",
				extractionLevel: 1,
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.FileExistsErrors = map[string]error{withArgs.archivePath: fmt.Errorf("error")}
				return utils
			},
			wantErr: true,
		},
		{
			name: "archive does not exist",
			args: args{
				archivePath:     "archive.tgz",
				targetPath:      "target",
				extractionLevel: 1,
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				return newSapDwCStageReleaseMockUtils(t) // not adding any files to utils.FilesMock makes FileExists return (false, nil) by default
			},
			wantErr: true,
		},
		{
			name: "error during extraction",
			args: args{
				archivePath:     "archive.tgz",
				targetPath:      "target",
				extractionLevel: 1,
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.AddFile(withArgs.archivePath, []byte("content"))
				utils.On("Untar", withArgs.archivePath, withArgs.targetPath, withArgs.extractionLevel).Return(fmt.Errorf("error"))
				return utils
			},
			wantErr: true,
		},
		{
			name: "successful extraction of tar archive",
			args: args{
				archivePath:     "archive.tar",
				targetPath:      "target",
				extractionLevel: 1,
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.AddFile(withArgs.archivePath, []byte("content"))
				utils.On("Untar", withArgs.archivePath, withArgs.targetPath, withArgs.extractionLevel).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "successful extraction of zip archive",
			args: args{
				archivePath: "archive.zip",
				targetPath:  "target",
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.AddFile(withArgs.archivePath, []byte("content"))
				utils.On("Unzip", withArgs.archivePath, withArgs.targetPath).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "successful extraction of mtar archive",
			args: args{
				archivePath: "archive.mtar",
				targetPath:  "target",
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.AddFile(withArgs.archivePath, []byte("content"))
				utils.On("Unzip", withArgs.archivePath, withArgs.targetPath).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "unsupported archive type",
			args: args{
				archivePath: "archive.xyz",
				targetPath:  "target",
			},
			prepareUtils: func(t *testing.T, withArgs args) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				utils.FilesMock.AddFile(withArgs.archivePath, []byte("content"))
				return utils
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			utils := test.prepareUtils(t, test.args)
			err := extractArchive(utils, test.args.archivePath, test.args.targetPath, test.args.extractionLevel)
			if (err != nil) != test.wantErr {
				t.Fatalf("extractArchive() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_extractHelmChart(t *testing.T) {
	t.Parallel()
	type args struct {
		globalConfiguration dwc.GlobalConfiguration
	}
	type testCase struct {
		name         string
		args         args
		prepareUtils func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils
		wantErr      bool
	}
	tests := []testCase{
		{
			name: "successful extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					HelmChartDirectory:     "helm",
					HelmChartURL:           "http://the-dir/the-file.tgz",
					DownloadedArchivesPath: "the-path",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				helmArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, filepath.Base(withArgs.HelmChartURL))
				utils.FilesMock.AddFile(helmArchivePath, []byte("content"))
				utils.On("Untar", helmArchivePath, "helm", 1).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "successful extraction with custom helm chart directory",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					HelmChartDirectory:     "chart",
					HelmChartURL:           "http://the-dir/the-file.tgz",
					DownloadedArchivesPath: "the-path",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				helmArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, filepath.Base(withArgs.HelmChartURL))
				utils.FilesMock.AddFile(helmArchivePath, []byte("content"))
				utils.On("Untar", helmArchivePath, "chart", 1).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "failed extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					HelmChartDirectory:     "helm",
					HelmChartURL:           "the-url.tgz",
					DownloadedArchivesPath: "the-path",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				helmArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, filepath.Base(withArgs.HelmChartURL))
				utils.FilesMock.FileExistsErrors = map[string]error{helmArchivePath: fmt.Errorf("error")}
				return utils
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			utils := test.prepareUtils(t, test.args.globalConfiguration)
			err := extractHelmChart(test.args.globalConfiguration, utils)
			if (err != nil) != test.wantErr {
				t.Fatalf("extractHelmChart() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_extractUIResources(t *testing.T) {
	t.Parallel()
	type args struct {
		globalConfiguration        dwc.GlobalConfiguration
		pattern                    string
		fileNameThatMatchesPattern string
		targetPath                 string
	}
	type testCase struct {
		name         string
		args         args
		prepareUtils func(t *testing.T, withArgs dwc.GlobalConfiguration, fileNameThatMatchesPattern string) sapDwCStageReleaseUtils
		wantErr      bool
	}
	tests := []testCase{
		{
			name: "successful extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-path",
				},
				pattern:                    "*-test-pattern-*",
				fileNameThatMatchesPattern: "file-that-matches-the-test-pattern-0.0.1.tgz",
				targetPath:                 "target",
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration, fileNameThatMatchesPattern string) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				uiArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, fileNameThatMatchesPattern)
				utils.FilesMock.AddFile(uiArchivePath, []byte("content"))
				utils.On("Untar", uiArchivePath, "target", 1).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "no matches found for pattern",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-path",
				},
				pattern:                    "*-test-pattern-*",
				fileNameThatMatchesPattern: "file-that-matches-the-test-pattern-0.0.1.tgz",
				targetPath:                 "",
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration, fileNameThatMatchesPattern string) sapDwCStageReleaseUtils {
				return newSapDwCStageReleaseMockUtils(t)
			},
			wantErr: true,
		},
		{
			name: "failed extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-path",
				},
				pattern:                    "*-test-pattern-*",
				fileNameThatMatchesPattern: "file-that-matches-the-test-pattern-0.0.1.tgz",
				targetPath:                 "",
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration, fileNameThatMatchesPattern string) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				uiArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, fileNameThatMatchesPattern)
				utils.FilesMock.AddFile(uiArchivePath, []byte("content"))
				utils.FilesMock.FileExistsErrors = map[string]error{uiArchivePath: fmt.Errorf("error")}
				return utils
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			utils := test.prepareUtils(t, test.args.globalConfiguration, test.args.fileNameThatMatchesPattern)
			err := extractUIResources(test.args.globalConfiguration, utils, test.args.pattern, test.args.targetPath)
			if (err != nil) != test.wantErr {
				t.Fatalf("extractUIResources() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_extractMTARArchive(t *testing.T) {
	t.Parallel()
	type args struct {
		globalConfiguration dwc.GlobalConfiguration
	}
	type testCase struct {
		name         string
		args         args
		prepareUtils func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils
		wantErr      bool
	}
	tests := []testCase{
		{
			name: "successful extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarFilePath:           "the-mtar-file-path.mtar",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				mtarArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, withArgs.MtarFilePath)
				utils.FilesMock.AddFile(mtarArchivePath, []byte("content"))
				utils.On("Unzip", mtarArchivePath, mtarExtractionDestination).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "no mtar archive with provided name found",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarFilePath:           "the-mtar-file-path.mtar",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				return newSapDwCStageReleaseMockUtils(t)
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			utils := test.prepareUtils(t, test.args.globalConfiguration)
			err := extractMTARArchive(test.args.globalConfiguration, utils)
			if (err != nil) != test.wantErr {
				t.Fatalf("extractMTARArchive() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_extractUIFilesFromMTARArchive(t *testing.T) {
	t.Parallel()
	type args struct {
		globalConfiguration dwc.GlobalConfiguration
	}
	type testCase struct {
		name         string
		args         args
		prepareUtils func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils
		wantErr      bool
	}
	tests := []testCase{
		{
			name: "successful extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarUIPath:             "ui",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				uiArchivePath := filepath.Join(mtarExtractionDestination, dwcUIAppContentModule, withArgs.MtarUIPath, "data.zip")
				utils.FilesMock.AddFile(uiArchivePath, []byte("content"))
				utils.On("Unzip", uiArchivePath, withArgs.DownloadedArchivesPath).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "no archive with provided name found",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarUIPath:             "ui",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				return newSapDwCStageReleaseMockUtils(t)
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			utils := test.prepareUtils(t, test.args.globalConfiguration)
			err := extractUIFilesFromMTARArchive(test.args.globalConfiguration, utils)
			if (err != nil) != test.wantErr {
				t.Fatalf("extractUIFilesFromMTARArchive() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_getAppNameUnique(t *testing.T) {
	t.Parallel()
	type args struct {
		artifactConfiguration dwc.ArtifactConfiguration
	}
	type testCase struct {
		name    string
		args    args
		want    string
		wantErr bool
	}
	tests := []testCase{
		{
			name: "unique app name set via appName property",
			args: args{
				artifactConfiguration: dwc.ArtifactConfiguration{
					AppName: "myApp",
				},
			},
			want:    "myApp",
			wantErr: false,
		},
		{
			name: "unique app name set via a single apps entry",
			args: args{
				artifactConfiguration: dwc.ArtifactConfiguration{
					Apps: []map[string]interface{}{map[string]interface{}{"name": "myApp"}},
				},
			},
			want:    "myApp",
			wantErr: false,
		},
		{
			name: "non-unique app names set via multiple apps entries",
			args: args{
				artifactConfiguration: dwc.ArtifactConfiguration{
					Apps: []map[string]interface{}{
						map[string]interface{}{"name": "myApp1"},
						map[string]interface{}{"name": "myApp2"},
					},
				},
			},
			want:    "",
			wantErr: true,
		},
		{
			name: "no app name provided",
			args: args{
				artifactConfiguration: dwc.ArtifactConfiguration{},
			},
			want:    "",
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got, err := getAppNameUnique(test.args.artifactConfiguration)
			if (err != nil) != test.wantErr {
				t.Fatalf("getAppNameUnique() error = %v, wantErr %v", err, test.wantErr)
			}
			assert.Equalf(t, test.want, got, "getAppNameUnique(%v)", test.args.artifactConfiguration)
		})
	}
}

func Test_retrieveUIAppsFromMTA(t *testing.T) {
	t.Parallel()
	type args struct {
		globalConfiguration   dwc.GlobalConfiguration
		artifactConfiguration dwc.ArtifactConfiguration
	}
	type testCase struct {
		name         string
		args         args
		prepareUtils func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils
		wantErr      bool
	}
	tests := []testCase{
		{
			name: "successful extraction",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarFilePath:           "the-mtar-file-path.mtar",
					MtarUIPath:             "ui",
				},
				artifactConfiguration: dwc.ArtifactConfiguration{
					AppName: "myApp",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)

				mtarArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, withArgs.MtarFilePath)
				utils.FilesMock.AddFile(mtarArchivePath, []byte("content"))
				utils.On("Unzip", mtarArchivePath, mtarExtractionDestination).Return(nil)

				uiArchivePath := filepath.Join(mtarExtractionDestination, dwcUIAppContentModule, withArgs.MtarUIPath, "data.zip")
				utils.FilesMock.AddFile(uiArchivePath, []byte("content"))
				utils.On("Unzip", uiArchivePath, withArgs.DownloadedArchivesPath).Return(nil)
				return utils
			},
			wantErr: false,
		},
		{
			name: "mtar archive not found",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarFilePath:           "the-mtar-file-path.mtar",
					MtarUIPath:             "ui",
				},
				artifactConfiguration: dwc.ArtifactConfiguration{
					AppName: "myApp",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)
				return utils
			},
			wantErr: true,
		},
		{
			name: "UI archive not found",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarFilePath:           "the-mtar-file-path.mtar",
					MtarUIPath:             "ui",
				},
				artifactConfiguration: dwc.ArtifactConfiguration{
					AppName: "myApp",
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)

				mtarArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, withArgs.MtarFilePath)
				utils.FilesMock.AddFile(mtarArchivePath, []byte("content"))
				utils.On("Unzip", mtarArchivePath, mtarExtractionDestination).Return(nil)

				return utils
			},
			wantErr: true,
		},
		{
			name: "no unique app name provided",
			args: args{
				globalConfiguration: dwc.GlobalConfiguration{
					DownloadedArchivesPath: "the-downloaded-archives-path",
					MtarFilePath:           "the-mtar-file-path.mtar",
					MtarUIPath:             "ui",
				},
				artifactConfiguration: dwc.ArtifactConfiguration{
					Apps: []map[string]interface{}{
						map[string]interface{}{"name": "myApp1"},
						map[string]interface{}{"name": "myApp2"},
					},
				},
			},
			prepareUtils: func(t *testing.T, withArgs dwc.GlobalConfiguration) sapDwCStageReleaseUtils {
				utils := newSapDwCStageReleaseMockUtils(t)

				mtarArchivePath := filepath.Join(withArgs.DownloadedArchivesPath, withArgs.MtarFilePath)
				utils.FilesMock.AddFile(mtarArchivePath, []byte("content"))
				utils.On("Unzip", mtarArchivePath, mtarExtractionDestination).Return(nil)

				uiArchivePath := filepath.Join(mtarExtractionDestination, dwcUIAppContentModule, withArgs.MtarUIPath, "data.zip")
				utils.FilesMock.AddFile(uiArchivePath, []byte("content"))
				utils.On("Unzip", uiArchivePath, withArgs.DownloadedArchivesPath).Return(nil)
				return utils
			},
			wantErr: true,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			utils := test.prepareUtils(t, test.args.globalConfiguration)
			err := retrieveUIAppsFromMTA(test.args.globalConfiguration, &test.args.artifactConfiguration, utils)
			if (err != nil) != test.wantErr {
				t.Fatalf("retrieveUIAppsFromMTA() error = %v, wantErr %v", err, test.wantErr)
			}
		})
	}
}

func Test_deriveAdditionalDownloadURLs(t *testing.T) {
	t.Parallel()
	type args struct {
		deriveAdditionalDownloadURLs []dwc.DeriveAdditionalDownloadURLsEntry
		artifactUrl                  string
	}
	type testCase struct {
		name    string
		args    args
		want    map[string]string
		wantErr bool
	}
	tests := []testCase{
		{
			name: "literal replacement",
			args: args{
				deriveAdditionalDownloadURLs: []dwc.DeriveAdditionalDownloadURLsEntry{{
					Key:         "cn20",
					FindPattern: "common\\.repositories\\.cloud\\.sap",
					ReplaceWith: "common.repositories.sapcloud.cn",
				}},
				artifactUrl: "https://common.repositories.cloud.sap/artifacts/very-good-srv",
			},
			want:    map[string]string{"cn20": "https://common.repositories.sapcloud.cn/artifacts/very-good-srv"},
			wantErr: false,
		},
		{
			name: "replacement using capture groups",
			args: args{
				deriveAdditionalDownloadURLs: []dwc.DeriveAdditionalDownloadURLsEntry{{
					Key:         "cn20",
					FindPattern: "(common\\.repositories)\\.(cloud)\\.sap",
					ReplaceWith: "$1.sap$2.cn",
				}},
				artifactUrl: "https://common.repositories.cloud.sap/artifacts/very-good-srv",
			},
			want:    map[string]string{"cn20": "https://common.repositories.sapcloud.cn/artifacts/very-good-srv"},
			wantErr: false,
		},
		{
			name: "no match",
			args: args{
				deriveAdditionalDownloadURLs: []dwc.DeriveAdditionalDownloadURLsEntry{{
					Key:         "cn20",
					FindPattern: "unknown-artifactory\\.cloud\\.sap",
					ReplaceWith: "common.repositories.sapcloud.cn",
				}},
				artifactUrl: "https://common.repositories.cloud.sap/artifacts/very-good-srv",
			},
			want:    map[string]string{},
			wantErr: false,
		},
		{
			name: "invalid regex",
			args: args{
				deriveAdditionalDownloadURLs: []dwc.DeriveAdditionalDownloadURLsEntry{{
					Key:         "cn20",
					FindPattern: "invalid-regex(",
					ReplaceWith: "common.repositories.sapcloud.cn",
				}},
				artifactUrl: "https://common.repositories.cloud.sap/artifacts/very-good-srv",
			},
			want:    map[string]string(nil),
			wantErr: true,
		},
		{
			name: "multiple replacements",
			args: args{
				deriveAdditionalDownloadURLs: []dwc.DeriveAdditionalDownloadURLsEntry{
					{
						Key:         "cn20",
						FindPattern: "common\\.repositories\\.cloud\\.sap",
						ReplaceWith: "common.repositories.sapcloud.cn",
					},
					{
						Key:         "ap10",
						FindPattern: "common\\.repositories\\.cloud\\.sap",
						ReplaceWith: "common.repositories.sap.ap",
					},
				},
				artifactUrl: "https://common.repositories.cloud.sap/artifacts/very-good-srv",
			},
			want: map[string]string{
				"cn20": "https://common.repositories.sapcloud.cn/artifacts/very-good-srv",
				"ap10": "https://common.repositories.sap.ap/artifacts/very-good-srv",
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		test := tt
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			got, err := deriveAdditionalDownloadURLs(test.args.deriveAdditionalDownloadURLs, test.args.artifactUrl)
			if (err != nil) != test.wantErr {
				t.Fatalf("deriveAdditionalDownloadURLs() error = %v, wantErr %v", err, test.wantErr)
			}
			assert.Equalf(t, test.want, got, "deriveAdditionalDownloadURLs(%v, %v)", test.args.deriveAdditionalDownloadURLs, test.args.artifactUrl)
		})
	}
}
