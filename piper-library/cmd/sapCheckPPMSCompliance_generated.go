// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/gcs"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/piperenv"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/bmatcuk/doublestar"
	"github.com/spf13/cobra"
)

type sapCheckPPMSComplianceOptions struct {
	Assignees                      []string `json:"assignees,omitempty"`
	BlackduckProjectName           string   `json:"blackduckProjectName,omitempty"`
	BlackduckProjectNames          []string `json:"blackduckProjectNames,omitempty"`
	BuildVersion                   string   `json:"buildVersion,omitempty"`
	BuildVersionEndpoint           string   `json:"buildVersionEndpoint,omitempty"`
	ChangeRequestEndpoint          string   `json:"changeRequestEndpoint,omitempty"`
	ChangeRequestFileName          string   `json:"changeRequestFileName,omitempty"`
	ChannelID                      string   `json:"channelID,omitempty"`
	CustomScanVersion              string   `json:"customScanVersion,omitempty"`
	CreateBuildVersion             bool     `json:"createBuildVersion,omitempty"`
	CreateResultIssue              bool     `json:"createResultIssue,omitempty"`
	DetectServerURL                string   `json:"detectServerUrl,omitempty"`
	DetectToken                    string   `json:"detectToken,omitempty"`
	GithubAPIURL                   string   `json:"githubApiUrl,omitempty"`
	GithubToken                    string   `json:"githubToken,omitempty"`
	OrgToken                       string   `json:"orgToken,omitempty"`
	Owner                          string   `json:"owner,omitempty"`
	Password                       string   `json:"password,omitempty"`
	PpmsID                         string   `json:"ppmsID,omitempty"`
	PullRequestMode                bool     `json:"pullRequestMode,omitempty"`
	ReportFileName                 string   `json:"reportFileName,omitempty"`
	ReportName                     string   `json:"reportName,omitempty"`
	ReportTitle                    string   `json:"reportTitle,omitempty"`
	Repository                     string   `json:"repository,omitempty"`
	ServerURL                      string   `json:"serverUrl,omitempty"`
	Timeout                        int      `json:"timeout,omitempty"`
	UploadChangeRequest            bool     `json:"uploadChangeRequest,omitempty"`
	Username                       string   `json:"username,omitempty"`
	UserToken                      string   `json:"userToken,omitempty"`
	Version                        string   `json:"version,omitempty"`
	VersioningModel                string   `json:"versioningModel,omitempty" validate:"possible-values=major major-minor semantic full"`
	WhitesourceProductName         string   `json:"whitesourceProductName,omitempty"`
	WhitesourceProductToken        string   `json:"whitesourceProductToken,omitempty"`
	WhitesourceProjectNames        []string `json:"whitesourceProjectNames,omitempty"`
	WhitesourceProjectNamesPattern string   `json:"whitesourceProjectNamesPattern,omitempty"`
	RunComplianceCheckWithDetect   bool     `json:"runComplianceCheckWithDetect,omitempty"`
}

type sapCheckPPMSComplianceInflux struct {
	step_data struct {
		fields struct {
			ppms string
		}
		tags struct {
		}
	}
}

func (i *sapCheckPPMSComplianceInflux) persist(path, resourceName string) {
	measurementContent := []struct {
		measurement string
		valType     string
		name        string
		value       interface{}
	}{
		{valType: config.InfluxField, measurement: "step_data", name: "ppms", value: i.step_data.fields.ppms},
	}

	errCount := 0
	for _, metric := range measurementContent {
		err := piperenv.SetResourceParameter(path, resourceName, filepath.Join(metric.measurement, fmt.Sprintf("%vs", metric.valType), metric.name), metric.value)
		if err != nil {
			log.Entry().WithError(err).Error("Error persisting influx environment.")
			errCount++
		}
	}
	if errCount > 0 {
		log.Entry().Error("failed to persist Influx environment")
	}
}

type sapCheckPPMSComplianceReports struct {
}

func (p *sapCheckPPMSComplianceReports) persist(stepConfig sapCheckPPMSComplianceOptions, gcpJsonKeyFilePath string, gcsBucketId string, gcsFolderPath string, gcsSubFolder string) {
	if gcsBucketId == "" {
		log.Entry().Info("persisting reports to GCS is disabled, because gcsBucketId is empty")
		return
	}
	log.Entry().Info("Uploading reports to Google Cloud Storage...")
	content := []gcs.ReportOutputParam{
		{FilePattern: "**/piper_whitesource_ppms_report.*", ParamRef: "", StepResultType: "whitesource-ip"},
		{FilePattern: "**/piper_blackduck_ppms_report.*", ParamRef: "", StepResultType: "blackduck-ip"},
	}

	gcsClient, err := gcs.NewClient(gcpJsonKeyFilePath, "")
	if err != nil {
		log.Entry().Errorf("creation of GCS client failed: %v", err)
		return
	}
	defer gcsClient.Close()
	structVal := reflect.ValueOf(&stepConfig).Elem()
	inputParameters := map[string]string{}
	for i := 0; i < structVal.NumField(); i++ {
		field := structVal.Type().Field(i)
		if field.Type.String() == "string" {
			paramName := strings.Split(field.Tag.Get("json"), ",")
			paramValue, _ := structVal.Field(i).Interface().(string)
			inputParameters[paramName[0]] = paramValue
		}
	}
	if err := gcs.PersistReportsToGCS(gcsClient, content, inputParameters, gcsFolderPath, gcsBucketId, gcsSubFolder, doublestar.Glob, os.Stat); err != nil {
		log.Entry().Errorf("failed to persist reports: %v", err)
	}
}

// SapCheckPPMSComplianceCommand This step is related to Free and Open Source Software (FOSS) in your development project (your delivery).
func SapCheckPPMSComplianceCommand() *cobra.Command {
	const STEP_NAME = "sapCheckPPMSCompliance"

	metadata := sapCheckPPMSComplianceMetadata()
	var stepConfig sapCheckPPMSComplianceOptions
	var startTime time.Time
	var influx sapCheckPPMSComplianceInflux
	var reports sapCheckPPMSComplianceReports
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapCheckPPMSComplianceCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "This step is related to Free and Open Source Software (FOSS) in your development project (your delivery).",
		Long: `This step is related to Free and Open Source Software (FOSS) in your development project (your delivery).
It cross-checks that you have declared all FOSS of your development project in the corresponding model of your delivery in PPMS (usually a build version (BV) in your software component version (SCV)).

It will fetch PPMS FOSS IDs based on your current WhiteSource or BlackDuck scan results as well as the PPMS FOSS entries contained in your PPMS SCV.
Then it will map both by using the PPMS FOSS ID.
The step will fail if the BOM in PPMS deviates from the BOM identified via WhiteSource or BlackDuck, unless the automatic PPMS upload functionality is switched on.

In case some FOSS identified via WhiteSource or BlackDuck do not have a counterpart in PPMS yet (= no PPMS FOSS ID known), the upload to PPMS will happen nevertheless **in accordance to the [Licensing Product standard guidelines](https://wiki.wdf.sap.corp/wiki/x/az4siQ) which prefer up-to-date declarations over completeness**.

Execution will generate a report, which shows the missing FOSS entries. If automatic PPMS upload is not configured, you can directly use the appended link to request the declaration for your software component version.
The report will also contain the risk rating for the found PPMS FOSS entries.

!!! tip "Recommendation: activate automatic PPMS uploads"
    It is highly recommended to activate the automatic upload of PPMS change requests as well as the automatic creation of PPMS build versions.

    This helps you to have an unattended process without manual interventions.

!!! note "For usage with WhiteSource: this step requires a WhiteSource product token"
    This step requires a WhiteSource product token in order to query the WhiteSource system for product details!

    Since a WhiteSource product token is also required for the WhiteSource scan it is best to maintain the parameter ` + "`" + `whitesourceProductToken` + "`" + ` in the ` + "`" + `general` + "`" + ` section of the configuration.

!!! note "For usage with BlackDuck: custom serverUrl should use alias parameter name"
    If you are using a server different from the default value and have configured the BlackDuck parameters
    in the 'detectExecuteScan' step's configs, please use the alias 'detectServerUrl' instead of 'serverUrl' to set the URL.
    Using custom 'serverUrl' in pipelines may conflict with the serverUrl of the PPMS step.`,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)
			log.RegisterSecret(stepConfig.DetectToken)
			log.RegisterSecret(stepConfig.GithubToken)
			log.RegisterSecret(stepConfig.Password)
			log.RegisterSecret(stepConfig.Username)
			log.RegisterSecret(stepConfig.UserToken)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				influx.persist(piperOsCmd.GeneralConfig.EnvRootPath, "influx")
				reports.persist(stepConfig, piperOsCmd.GeneralConfig.GCPJsonKeyFilePath, piperOsCmd.GeneralConfig.GCSBucketId, piperOsCmd.GeneralConfig.GCSFolderPath, piperOsCmd.GeneralConfig.GCSSubFolder)
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapCheckPPMSCompliance(stepConfig, &stepTelemetryData, &influx)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapCheckPPMSComplianceFlags(createSapCheckPPMSComplianceCmd, &stepConfig)
	return createSapCheckPPMSComplianceCmd
}

func addSapCheckPPMSComplianceFlags(cmd *cobra.Command, stepConfig *sapCheckPPMSComplianceOptions) {
	cmd.Flags().StringSliceVar(&stepConfig.Assignees, "assignees", []string{``}, "Defines the assignees for the Github Issue created/updated with the results of the scan as a list of login names.")
	cmd.Flags().StringVar(&stepConfig.BlackduckProjectName, "blackduckProjectName", os.Getenv("PIPER_blackduckProjectName"), "Name of the BlackDuck project which should be used for comparison (mandatory when using BlackDuck).")
	cmd.Flags().StringSliceVar(&stepConfig.BlackduckProjectNames, "blackduckProjectNames", []string{}, "Names of BlackDuck projects which should be used for comparison. [If this parameter is used - it overrides blackduckProjectName parameter].")
	cmd.Flags().StringVar(&stepConfig.BuildVersion, "buildVersion", os.Getenv("PIPER_buildVersion"), "PPMS build version of affected PPMS software component version.")
	cmd.Flags().StringVar(&stepConfig.BuildVersionEndpoint, "buildVersionEndpoint", `/sap/internal/ppms/api/changerequest/v1/cvbv`, "API endpoint for PPMS Build Version API")
	cmd.Flags().StringVar(&stepConfig.ChangeRequestEndpoint, "changeRequestEndpoint", `/sap/internal/ppms/api/changerequest/v1/cvpart`, "API endpoint for PPMS Change Request API")
	cmd.Flags().StringVar(&stepConfig.ChangeRequestFileName, "changeRequestFileName", `piper_foss-changerequest.json`, "Name of the file containing the PPMS change request document")
	cmd.Flags().StringVar(&stepConfig.ChannelID, "channelID", `GTMC_10`, "ID of the PPMS Go-to-market channel")
	cmd.Flags().StringVar(&stepConfig.CustomScanVersion, "customScanVersion", os.Getenv("PIPER_customScanVersion"), "Custom version of the BlackDuck project used as source.")
	cmd.Flags().BoolVar(&stepConfig.CreateBuildVersion, "createBuildVersion", false, "Defines if a new build version should be created in PPMS based on value available for `ppmsBuildVersion`.")
	cmd.Flags().BoolVar(&stepConfig.CreateResultIssue, "createResultIssue", false, "Activate creation of a result issue in GitHub.")
	cmd.Flags().StringVar(&stepConfig.DetectServerURL, "detectServerUrl", `https://sap.blackducksoftware.com`, "URL to the Synopsis Detect (formerly BlackDuck) Server.")
	cmd.Flags().StringVar(&stepConfig.DetectToken, "detectToken", os.Getenv("PIPER_detectToken"), "API token to be used for connectivity with Synopsis Detect server - aka BlackDuck (mandatory when using Detect/BlackDuck).")
	cmd.Flags().StringVar(&stepConfig.GithubAPIURL, "githubApiUrl", `https://api.github.com`, "Set the GitHub API URL.")
	cmd.Flags().StringVar(&stepConfig.GithubToken, "githubToken", os.Getenv("PIPER_githubToken"), "GitHub personal access token as per https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line")
	cmd.Flags().StringVar(&stepConfig.OrgToken, "orgToken", `6971b2eec2d3420bad0caf173ec629f6a3c7d3ba63f3445ab99ffdbf1acfb1d0`, "Whitesource organization token (mandatory when using WhiteSource).")
	cmd.Flags().StringVar(&stepConfig.Owner, "owner", os.Getenv("PIPER_owner"), "Set the GitHub organization.")
	cmd.Flags().StringVar(&stepConfig.Password, "password", os.Getenv("PIPER_password"), "Password for PPMS system. In Jenkins environment automatically set based on credentials.")
	cmd.Flags().StringVar(&stepConfig.PpmsID, "ppmsID", os.Getenv("PIPER_ppmsID"), "PPMS object number of PPMS software component version or PPMS product version to which the found FOSS objects are compared. If you want to use the PPMS change request upload functionality, please make sure to use a PPMS software component version.")
	cmd.Flags().BoolVar(&stepConfig.PullRequestMode, "pullRequestMode", false, "Defines if verification takes place in pull-request voting. In this case upload request to PPMS will be skipped.")
	cmd.Flags().StringVar(&stepConfig.ReportFileName, "reportFileName", `piper_whitesource_ppms_report`, "[Deprecated] File name of the generated comparison report is now automatically determined by the step.")
	cmd.Flags().StringVar(&stepConfig.ReportName, "reportName", `PPMS Compliance Check Report`, "Name of the report which will be available in Jenkins.")
	cmd.Flags().StringVar(&stepConfig.ReportTitle, "reportTitle", os.Getenv("PIPER_reportTitle"), "Title of the generated report. If empty, `reportName` value will be used.")
	cmd.Flags().StringVar(&stepConfig.Repository, "repository", os.Getenv("PIPER_repository"), "Set the GitHub repository.")
	cmd.Flags().StringVar(&stepConfig.ServerURL, "serverUrl", `https://i7p.wdf.sap.corp`, "HTTPS server URL for PPMS system")
	cmd.Flags().IntVar(&stepConfig.Timeout, "timeout", 900, "Timeout in seconds until an HTTP call is forcefully terminated.")
	cmd.Flags().BoolVar(&stepConfig.UploadChangeRequest, "uploadChangeRequest", false, "Defines if a change request document should be uploaded to PPMS based on the comparison results.")
	cmd.Flags().StringVar(&stepConfig.Username, "username", os.Getenv("PIPER_username"), "User name for PPMS system. In Jenkins environment automatically set based on credentials.")
	cmd.Flags().StringVar(&stepConfig.UserToken, "userToken", os.Getenv("PIPER_userToken"), "User token to access WhiteSource (mandatory when using WhiteSource). In Jenkins use case this is automatically filled through the credentials.")
	cmd.Flags().StringVar(&stepConfig.Version, "version", os.Getenv("PIPER_version"), "Defines the version number of the artifact being build in the pipeline. It is used for build version creation and as source for the BlackDuck version.")
	cmd.Flags().StringVar(&stepConfig.VersioningModel, "versioningModel", `major`, "The default project versioning model used for BlackDuck project versioning based on parameter `version`.")
	cmd.Flags().StringVar(&stepConfig.WhitesourceProductName, "whitesourceProductName", os.Getenv("PIPER_whitesourceProductName"), "Name of the WhiteSource product used for comparison.")
	cmd.Flags().StringVar(&stepConfig.WhitesourceProductToken, "whitesourceProductToken", os.Getenv("PIPER_whitesourceProductToken"), "Token of the WhiteSource product used for comparison (mandatory when using WhiteSource).")
	cmd.Flags().StringSliceVar(&stepConfig.WhitesourceProjectNames, "whitesourceProjectNames", []string{}, "List of WhiteSource projects used for comparison - typically provided automatically.")
	cmd.Flags().StringVar(&stepConfig.WhitesourceProjectNamesPattern, "whitesourceProjectNamesPattern", os.Getenv("PIPER_whitesourceProjectNamesPattern"), "A pattern to select whitesource projects for comparison.")
	cmd.Flags().BoolVar(&stepConfig.RunComplianceCheckWithDetect, "runComplianceCheckWithDetect", false, "Boolean flag to indicate Detect (Blackduck) scan instead of Whitesource to be used for PPMS compliance check.")

	cmd.MarkFlagRequired("buildVersionEndpoint")
	cmd.MarkFlagRequired("changeRequestEndpoint")
	cmd.MarkFlagRequired("changeRequestFileName")
	cmd.MarkFlagRequired("channelID")
	cmd.MarkFlagRequired("detectServerUrl")
	cmd.MarkFlagRequired("password")
	cmd.MarkFlagRequired("ppmsID")
	cmd.MarkFlagRequired("serverUrl")
	cmd.MarkFlagRequired("username")
}

// retrieve step metadata
func sapCheckPPMSComplianceMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapCheckPPMSCompliance",
			Aliases:     []config.Alias{{Name: "detectExecuteScan", Deprecated: false}, {Name: "executePPMSComplianceCheck", Deprecated: true}, {Name: "executePPMSWhitesourceComplianceCheck", Deprecated: true}},
			Description: "This step is related to Free and Open Source Software (FOSS) in your development project (your delivery).",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Secrets: []config.StepSecrets{
					{Name: "whitesourceUserTokenCredentialsId", Type: "jenkins"},
					{Name: "ppmsCredentialsId", Type: "jenkins"},
					{Name: "detectTokenCredentialsId", Description: "Jenkins 'Secret text' credentials ID containing the API token used to authenticate with the Synopsis Detect (formerly BlackDuck) Server.", Type: "jenkins", Aliases: []config.Alias{{Name: "blackduckTokenCredentialsId", Deprecated: false}}},
					{Name: "githubTokenCredentialsId", Description: "Jenkins 'Secret text' credentials ID containing token to authenticate to GitHub.", Type: "jenkins"},
				},
				Parameters: []config.StepParameters{
					{
						Name:        "assignees",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "[]string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     []string{``},
					},
					{
						Name:        "blackduckProjectName",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "projectName"}},
						Default:     os.Getenv("PIPER_blackduckProjectName"),
					},
					{
						Name:        "blackduckProjectNames",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "[]string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "projectNames"}},
						Default:     []string{},
					},
					{
						Name:        "buildVersion",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "ppmsBuildVersion"}},
						Default:     os.Getenv("PIPER_buildVersion"),
					},
					{
						Name:        "buildVersionEndpoint",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{{Name: "ppmsBuildVersionEndpoint"}},
						Default:     `/sap/internal/ppms/api/changerequest/v1/cvbv`,
					},
					{
						Name:        "changeRequestEndpoint",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{{Name: "ppmsChangeRequestEndpoint"}},
						Default:     `/sap/internal/ppms/api/changerequest/v1/cvpart`,
					},
					{
						Name:        "changeRequestFileName",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     `piper_foss-changerequest.json`,
					},
					{
						Name:        "channelID",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{{Name: "ppmsChannelID"}},
						Default:     `GTMC_10`,
					},
					{
						Name:        "customScanVersion",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_customScanVersion"),
					},
					{
						Name:        "createBuildVersion",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "ppmsBuildVersionCreation"}},
						Default:     false,
					},
					{
						Name: "createResultIssue",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "custom/isOptimizedAndScheduled",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "bool",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   false,
					},
					{
						Name:        "detectServerUrl",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     `https://sap.blackducksoftware.com`,
					},
					{
						Name: "detectToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "detectTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "detectTokenCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "detect",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "blackduckToken"}, {Name: "token"}},
						Default:   os.Getenv("PIPER_detectToken"),
					},
					{
						Name:        "githubApiUrl",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `https://api.github.com`,
					},
					{
						Name: "githubToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "githubTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "githubVaultSecretName",
								Type:    "vaultSecret",
								Default: "github",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "access_token"}},
						Default:   os.Getenv("PIPER_githubToken"),
					},
					{
						Name:        "orgToken",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `6971b2eec2d3420bad0caf173ec629f6a3c7d3ba63f3445ab99ffdbf1acfb1d0`,
					},
					{
						Name: "owner",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "github/owner",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "githubOrg"}},
						Default:   os.Getenv("PIPER_owner"),
					},
					{
						Name: "password",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "ppmsCredentialsId",
								Param: "password",
								Type:  "secret",
							},

							{
								Name:    "ppmsCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "ppms",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{{Name: "ppmsPassword"}},
						Default:   os.Getenv("PIPER_password"),
					},
					{
						Name:        "ppmsID",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_ppmsID"),
					},
					{
						Name:        "pullRequestMode",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"STAGES"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
					{
						Name:        "reportFileName",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `piper_whitesource_ppms_report`,
					},
					{
						Name:        "reportName",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `PPMS Compliance Check Report`,
					},
					{
						Name:        "reportTitle",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_reportTitle"),
					},
					{
						Name: "repository",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "github/repository",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "githubRepo"}},
						Default:   os.Getenv("PIPER_repository"),
					},
					{
						Name:        "serverUrl",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{{Name: "ppmsServerUrl"}},
						Default:     `https://i7p.wdf.sap.corp`,
					},
					{
						Name:        "timeout",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "int",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     900,
					},
					{
						Name:        "uploadChangeRequest",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "ppmsChangeRequestUpload"}},
						Default:     false,
					},
					{
						Name: "username",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "ppmsCredentialsId",
								Param: "username",
								Type:  "secret",
							},

							{
								Name:    "ppmsCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "ppms",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: true,
						Aliases:   []config.Alias{{Name: "ppmsUsername"}},
						Default:   os.Getenv("PIPER_username"),
					},
					{
						Name: "userToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "whitesourceUserTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "whitesourceUserTokenCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "whitesource",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "whitesourceUserToken"}},
						Default:   os.Getenv("PIPER_userToken"),
					},
					{
						Name: "version",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "artifactVersion",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "projectVersion"}},
						Default:   os.Getenv("PIPER_version"),
					},
					{
						Name:        "versioningModel",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{{Name: "defaultVersioningModel"}},
						Default:     `major`,
					},
					{
						Name:        "whitesourceProductName",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_whitesourceProductName"),
					},
					{
						Name:        "whitesourceProductToken",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_whitesourceProductToken"),
					},
					{
						Name: "whitesourceProjectNames",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "custom/whitesourceProjectNames",
							},
						},
						Scope:     []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:      "[]string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   []string{},
					},
					{
						Name:        "whitesourceProjectNamesPattern",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_whitesourceProjectNamesPattern"),
					},
					{
						Name:        "runComplianceCheckWithDetect",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES", "GENERAL"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
				},
			},
			Outputs: config.StepOutputs{
				Resources: []config.StepResources{
					{
						Name: "influx",
						Type: "influx",
						Parameters: []map[string]interface{}{
							{"name": "step_data", "fields": []map[string]string{{"name": "ppms"}}},
						},
					},
					{
						Name: "reports",
						Type: "reports",
						Parameters: []map[string]interface{}{
							{"filePattern": "**/piper_whitesource_ppms_report.*", "type": "whitesource-ip"},
							{"filePattern": "**/piper_blackduck_ppms_report.*", "type": "blackduck-ip"},
						},
					},
				},
			},
		},
	}
	return theMetaData
}
