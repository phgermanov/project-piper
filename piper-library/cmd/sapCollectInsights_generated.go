// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/gcs"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/bmatcuk/doublestar"
	"github.com/spf13/cobra"
)

type sapCollectInsightsOptions struct {
	DevOpsInsightsToken          string `json:"devOpsInsightsToken,omitempty"`
	DoraSystemTrustToken         string `json:"doraSystemTrustToken,omitempty"`
	TokenOrder                   string `json:"tokenOrder,omitempty"`
	DevOpsInsightsAPI            string `json:"devOpsInsightsAPI,omitempty"`
	GithubToken                  string `json:"githubToken,omitempty"`
	CommitID                     string `json:"commitId,omitempty"`
	PreviousReleaseCommitID      string `json:"previousReleaseCommitId,omitempty"`
	Branch                       string `json:"branch,omitempty"`
	GitOrganization              string `json:"gitOrganization,omitempty"`
	GitRepository                string `json:"gitRepository,omitempty"`
	GitInstance                  string `json:"gitInstance,omitempty"`
	GitURL                       string `json:"gitURL,omitempty"`
	ArtifactVersion              string `json:"artifactVersion,omitempty"`
	Identifier                   string `json:"identifier,omitempty"`
	DeploymentTarget             string `json:"deploymentTarget,omitempty"`
	SerializeIntermediateResults bool   `json:"serializeIntermediateResults,omitempty"`
	CollectChangeSetProduction   bool   `json:"collectChangeSetProduction,omitempty"`
	DeploymentTime               string `json:"deploymentTime,omitempty"`
	ChangeSetRetrieval           string `json:"changeSetRetrieval,omitempty" validate:"possible-values=orchestrator fourkeys btp"`
	DevOpsInsightsVersion        string `json:"devOpsInsightsVersion,omitempty"`
	GcsBucketID                  string `json:"gcsBucketID,omitempty"`
}

type sapCollectInsightsReports struct {
}

func (p *sapCollectInsightsReports) persist(stepConfig sapCollectInsightsOptions, gcpJsonKeyFilePath string, gcsBucketId string, gcsFolderPath string, gcsSubFolder string) {
	if gcsBucketId == "" {
		log.Entry().Info("persisting reports to GCS is disabled, because gcsBucketId is empty")
		return
	}
	log.Entry().Info("Uploading reports to Google Cloud Storage...")
	content := []gcs.ReportOutputParam{
		{FilePattern: "changes.txt", ParamRef: "", StepResultType: "log"},
	}

	gcsClient, err := gcs.NewClient(gcpJsonKeyFilePath, "")
	if err != nil {
		log.Entry().Errorf("creation of GCS client failed: %v", err)
		return
	}
	defer gcsClient.Close()
	structVal := reflect.ValueOf(&stepConfig).Elem()
	inputParameters := map[string]string{}
	for i := 0; i < structVal.NumField(); i++ {
		field := structVal.Type().Field(i)
		if field.Type.String() == "string" {
			paramName := strings.Split(field.Tag.Get("json"), ",")
			paramValue, _ := structVal.Field(i).Interface().(string)
			inputParameters[paramName[0]] = paramValue
		}
	}
	if err := gcs.PersistReportsToGCS(gcsClient, content, inputParameters, gcsFolderPath, gcsBucketId, gcsSubFolder, doublestar.Glob, os.Stat); err != nil {
		log.Entry().Errorf("failed to persist reports: %v", err)
	}
}

// SapCollectInsightsCommand This step provides the capability to collect metrics related to DevOps.
func SapCollectInsightsCommand() *cobra.Command {
	const STEP_NAME = "sapCollectInsights"

	metadata := sapCollectInsightsMetadata()
	var stepConfig sapCollectInsightsOptions
	var startTime time.Time
	var reports sapCollectInsightsReports
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapCollectInsightsCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "This step provides the capability to collect metrics related to DevOps.",
		Long: `This step enables SAP to collect various metrics about DevOps practices. The metrics are consumed to calculate the
DORA metrics, Deployment Frequency and Lead Time for Changes. The DORA relevant metrics which can be collected
utilizing this step are ` + "`" + `Lead Time for Changes` + "`" + ` (LT) and ` + "`" + `DeploymentFrequency` + "`" + ` (DF).
The ChangeSet necessary for LT is by default only collected for pipelines with deploymentTarget ` + "`" + `development` + "`" + `.
In case you are running on the GPP you solely need to configure the following in your .pipeline/config.yml file:
` + "`" + `` + "`" + `` + "`" + `yaml
sapCollectInsights:
  deploymentTarget: 'development' OR 'production'
  identifier: YOUR-MICROSERVICE-NAME
` + "`" + `` + "`" + `` + "`" + ``,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)
			log.RegisterSecret(stepConfig.DevOpsInsightsToken)
			log.RegisterSecret(stepConfig.DoraSystemTrustToken)
			log.RegisterSecret(stepConfig.GithubToken)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				reports.persist(stepConfig, piperOsCmd.GeneralConfig.GCPJsonKeyFilePath, piperOsCmd.GeneralConfig.GCSBucketId, piperOsCmd.GeneralConfig.GCSFolderPath, piperOsCmd.GeneralConfig.GCSSubFolder)
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapCollectInsights(stepConfig, &stepTelemetryData)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapCollectInsightsFlags(createSapCollectInsightsCmd, &stepConfig)
	return createSapCollectInsightsCmd
}

func addSapCollectInsightsFlags(cmd *cobra.Command, stepConfig *sapCollectInsightsOptions) {
	cmd.Flags().StringVar(&stepConfig.DevOpsInsightsToken, "devOpsInsightsToken", os.Getenv("PIPER_devOpsInsightsToken"), "DevOps Insights Token")
	cmd.Flags().StringVar(&stepConfig.DoraSystemTrustToken, "doraSystemTrustToken", os.Getenv("PIPER_doraSystemTrustToken"), "Access token for DevOps Insights as provided by Hyperspace System Trust. Precedence over the devOpsInsightsToken from Vault is controlled via the tokenOrder parameter.")
	cmd.Flags().StringVar(&stepConfig.TokenOrder, "tokenOrder", `i2`, "This field is used to define the order of the token to be used. Possible values are 'i2', 'trust'.")
	cmd.Flags().StringVar(&stepConfig.DevOpsInsightsAPI, "devOpsInsightsAPI", ``, "DevOpsInsights API base URL")
	cmd.Flags().StringVar(&stepConfig.GithubToken, "githubToken", os.Getenv("PIPER_githubToken"), "Token of Git user for Github access.")
	cmd.Flags().StringVar(&stepConfig.CommitID, "commitId", os.Getenv("PIPER_commitId"), "CommitId of the current build.")
	cmd.Flags().StringVar(&stepConfig.PreviousReleaseCommitID, "previousReleaseCommitId", os.Getenv("PIPER_previousReleaseCommitId"), "CommitId of the last release.")
	cmd.Flags().StringVar(&stepConfig.Branch, "branch", os.Getenv("PIPER_branch"), "Branch of the current build.")
	cmd.Flags().StringVar(&stepConfig.GitOrganization, "gitOrganization", os.Getenv("PIPER_gitOrganization"), "Git organization of the current build.")
	cmd.Flags().StringVar(&stepConfig.GitRepository, "gitRepository", os.Getenv("PIPER_gitRepository"), "Git repository of the current build.")
	cmd.Flags().StringVar(&stepConfig.GitInstance, "gitInstance", os.Getenv("PIPER_gitInstance"), "Git instance of the current build.")
	cmd.Flags().StringVar(&stepConfig.GitURL, "gitURL", os.Getenv("PIPER_gitURL"), "DEPRECATED. Git URL of the repository. Not needed anymore as we compose it from the other parameters.")
	cmd.Flags().StringVar(&stepConfig.ArtifactVersion, "artifactVersion", os.Getenv("PIPER_artifactVersion"), "The version assigned by artifactPrepareVersion to the uploaded log files/documents.")
	cmd.Flags().StringVar(&stepConfig.Identifier, "identifier", os.Getenv("PIPER_identifier"), "Identifier string for e.g. dedicated artifact version. Used for later mapping.")
	cmd.Flags().StringVar(&stepConfig.DeploymentTarget, "deploymentTarget", `development`, "Indicates the release status for the current pipeline run.")
	cmd.Flags().BoolVar(&stepConfig.SerializeIntermediateResults, "serializeIntermediateResults", false, "Use only for debug purpose. Creates two files collected_structure.json and gateway_response.json.")
	cmd.Flags().BoolVar(&stepConfig.CollectChangeSetProduction, "collectChangeSetProduction", false, "In case you are running a pipeline with deploymentTarget `production` you can force the step to collect the ChangeSet")
	cmd.Flags().StringVar(&stepConfig.DeploymentTime, "deploymentTime", os.Getenv("PIPER_deploymentTime"), "The UTC timestamp of when the deployment happened. Format `2006-01-02 15:04:05`. Uses current time if this parameter is empty")
	cmd.Flags().StringVar(&stepConfig.ChangeSetRetrieval, "changeSetRetrieval", `btp`, "DEPRECATED Defines the way a ChangeSet is retrieved. e.g. through cumulus or orchestrator")
	cmd.Flags().StringVar(&stepConfig.DevOpsInsightsVersion, "devOpsInsightsVersion", os.Getenv("PIPER_devOpsInsightsVersion"), "DevOpsInsights version pattern looks like this v.X.Y.Z, or dev refers to main version")
	cmd.Flags().StringVar(&stepConfig.GcsBucketID, "gcsBucketID", os.Getenv("PIPER_gcsBucketID"), "gcsBucketID/cumulusId of the current pipeline.")

	cmd.MarkFlagRequired("identifier")
	cmd.MarkFlagRequired("changeSetRetrieval")
}

// retrieve step metadata
func sapCollectInsightsMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapCollectInsights",
			Aliases:     []config.Alias{},
			Description: "This step provides the capability to collect metrics related to DevOps.",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Secrets: []config.StepSecrets{
					{Name: "githubTokenCredentialsId", Description: "Jenkins 'Secret text' credentials ID containing the token used to authenticate with the Github server.", Type: "jenkins"},
					{Name: "devOpsInsightsTokenCredentialsId", Description: "Jenkins 'Secret text' DevOpsInsights token, only use if you dont use Vault.", Type: "jenkins"},
				},
				Parameters: []config.StepParameters{
					{
						Name: "devOpsInsightsToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "devOpsInsightsTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "devOpsInsightsTokenVaultSecretName",
								Type:    "vaultSecret",
								Default: "devops-insights",
							},
						},
						Scope:     []string{"PARAMETERS", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "token"}},
						Default:   os.Getenv("PIPER_devOpsInsightsToken"),
					},
					{
						Name: "doraSystemTrustToken",
						ResourceRef: []config.ResourceReference{
							{
								Name:    "doraTrustSecretName",
								Type:    "systemTrustSecret",
								Default: "dora",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_doraSystemTrustToken"),
					},
					{
						Name:        "tokenOrder",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `i2`,
					},
					{
						Name:        "devOpsInsightsAPI",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"GENERAL", "PARAMETERS", "STAGES", "STEPS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     ``,
					},
					{
						Name: "githubToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "githubTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "githubTokenCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "github",
							},
						},
						Scope:     []string{"PARAMETERS", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "access_token"}},
						Default:   os.Getenv("PIPER_githubToken"),
					},
					{
						Name: "commitId",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/headCommitId",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_commitId"),
					},
					{
						Name: "previousReleaseCommitId",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/previousReleaseRef",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_previousReleaseCommitId"),
					},
					{
						Name: "branch",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/branch",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_branch"),
					},
					{
						Name: "gitOrganization",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/organization",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_gitOrganization"),
					},
					{
						Name: "gitRepository",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/repository",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_gitRepository"),
					},
					{
						Name: "gitInstance",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/instance",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_gitInstance"),
					},
					{
						Name: "gitURL",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "git/url",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_gitURL"),
					},
					{
						Name: "artifactVersion",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "artifactVersion",
							},
						},
						Scope:     []string{"PARAMETERS", "STAGES", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_artifactVersion"),
					},
					{
						Name:        "identifier",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_identifier"),
					},
					{
						Name:        "deploymentTarget",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `development`,
					},
					{
						Name:        "serializeIntermediateResults",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
					{
						Name:        "collectChangeSetProduction",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
					{
						Name:        "deploymentTime",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_deploymentTime"),
					},
					{
						Name:        "changeSetRetrieval",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     `btp`,
					},
					{
						Name:        "devOpsInsightsVersion",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "STAGES"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_devOpsInsightsVersion"),
					},
					{
						Name: "gcsBucketID",
						ResourceRef: []config.ResourceReference{
							{
								Name:  "commonPipelineEnvironment",
								Param: "custom/gcsBucketID",
							},
						},
						Scope:     []string{"PARAMETERS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{},
						Default:   os.Getenv("PIPER_gcsBucketID"),
					},
				},
			},
			Outputs: config.StepOutputs{
				Resources: []config.StepResources{
					{
						Name: "reports",
						Type: "reports",
						Parameters: []map[string]interface{}{
							{"filePattern": "changes.txt", "type": "log"},
						},
					},
				},
			},
		},
	}
	return theMetaData
}
