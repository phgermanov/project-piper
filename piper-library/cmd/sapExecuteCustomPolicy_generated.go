// Code generated by piper's step-generator. DO NOT EDIT.

package cmd

import (
	"fmt"
	"os"
	"time"

	piperOsCmd "github.com/SAP/jenkins-library/cmd"
	"github.com/SAP/jenkins-library/pkg/config"
	"github.com/SAP/jenkins-library/pkg/gcp"
	"github.com/SAP/jenkins-library/pkg/log"
	"github.com/SAP/jenkins-library/pkg/splunk"
	"github.com/SAP/jenkins-library/pkg/telemetry"
	"github.com/SAP/jenkins-library/pkg/validation"
	"github.com/spf13/cobra"
)

type sapExecuteCustomPolicyOptions struct {
	PolicyKey                 string `json:"policyKey,omitempty"`
	EvidenceFile              string `json:"evidenceFile,omitempty"`
	PolicyPath                string `json:"policyPath,omitempty"`
	FailOnPolicyViolation     bool   `json:"failOnPolicyViolation,omitempty"`
	ResultFile                string `json:"resultFile,omitempty"`
	GenerateJunitReport       bool   `json:"generateJunitReport,omitempty"`
	GithubToken               string `json:"githubToken,omitempty"`
	CumulusPolicyAgentVersion string `json:"cumulusPolicyAgentVersion,omitempty"`
}

// SapExecuteCustomPolicyCommand Execute a custom policy.
func SapExecuteCustomPolicyCommand() *cobra.Command {
	const STEP_NAME = "sapExecuteCustomPolicy"

	metadata := sapExecuteCustomPolicyMetadata()
	var stepConfig sapExecuteCustomPolicyOptions
	var startTime time.Time
	var logCollector *log.CollectorHook
	var splunkClient *splunk.Splunk
	telemetryClient := &telemetry.Telemetry{}

	var createSapExecuteCustomPolicyCmd = &cobra.Command{
		Use:   STEP_NAME,
		Short: "Execute a custom policy.",
		Long: `This step evaluates custom policies which you can use to validate the quality of your software.

For the evaluation, you need to provide an evidence file which contains the measured properties of your software and the custom policy which contains the constraints.
This step validates the evidence file against the custom policy and stores the result in a json file.

It uses the [Open Policy Agent (OPA)](https://www.openpolicyagent.org/) as policy execution engine, which means that policies are written in the [Rego policy language](https://www.openpolicyagent.org/docs/latest/policy-language/).
You are free in the way you implement your policy, the only constraint is that the produced policy result has to match the [Cumulus result schema](https://github.tools.sap/P4TEAM/cumulus-file-schema/blob/main/schema/v1/custom-policy-validation-result/custom-policy-validation-result.schema.json).
By default policy violations will abort the pipeline (can be changed by ` + "`" + `failOnPolicyViolation` + "`" + ` parameter to ` + "`" + `false` + "`" + `).

Example:
In order to execute a custom policy you have to call the step sapExecuteCustomPolicy i.e. by using a piper extension.

` + "`" + `` + "`" + `` + "`" + `
sapExecuteCustomPolicy script: script, policyKey: 'MY-POLICY-1', evidenceFile: 'my-evidence-1.json'
` + "`" + `` + "`" + `` + "`" + `

A working showcase with [piper extension](https://github.wdf.sap.corp/cumulus/cumulus-showcase-nestjs/blob/master/.pipeline/extensions/Central%20Build.groovy) and a policy can be found in the [cumulus-showcase-nestjs](https://github.wdf.sap.corp/cumulus/cumulus-showcase-nestjs/tree/master/.policy/code_coverage) repository.

Cumulus Integration:

The generated result file can be uploaded to [Cumulus](https://go.sap.corp/piper/steps/sapCumulusUpload/):
` + "`" + `` + "`" + `` + "`" + `
sapCumulusUpload script: this, filePattern: 'custom-policy-result/MY-POLICY-1/**/*.json', subFolderPath: 'MY-POLICY-1', stepResultType: 'custom-policy-result'
` + "`" + `` + "`" + `` + "`" + `
This can be used for documentation purposes and to display the results in the [Cumulus pipeline dashboard](https://wiki.one.int.sap/wiki/x/icIy1g#PoliciesasCode-WherecanIseepolicyresults?).`,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			startTime = time.Now()
			log.SetStepName(STEP_NAME)
			log.SetVerbose(piperOsCmd.GeneralConfig.Verbose)

			piperOsCmd.GeneralConfig.GitHubAccessTokens = piperOsCmd.ResolveAccessTokens(piperOsCmd.GeneralConfig.GitHubTokens)

			path, err := os.Getwd()
			if err != nil {
				return err
			}
			fatalHook := &log.FatalHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID, Path: path}
			log.RegisterHook(fatalHook)

			err = piperOsCmd.PrepareConfig(cmd, &metadata, STEP_NAME, &stepConfig, config.OpenPiperFile)
			if err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			// Set step error patterns for improved error detection
			stepErrors := make([]log.StepError, len(metadata.Metadata.Errors))
			for i, err := range metadata.Metadata.Errors {
				stepErrors[i] = log.StepError{
					Pattern:  err.Pattern,
					Message:  err.Message,
					Category: err.Category,
				}
			}
			log.SetStepErrors(stepErrors)
			log.RegisterSecret(stepConfig.GithubToken)

			if len(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn) > 0 {
				sentryHook := log.NewSentryHook(piperOsCmd.GeneralConfig.HookConfig.SentryConfig.Dsn, piperOsCmd.GeneralConfig.CorrelationID)
				log.RegisterHook(&sentryHook)
			}

			if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 || len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
				splunkClient = &splunk.Splunk{}
				logCollector = &log.CollectorHook{CorrelationID: piperOsCmd.GeneralConfig.CorrelationID}
				log.RegisterHook(logCollector)
			}

			if err = log.RegisterANSHookIfConfigured(piperOsCmd.GeneralConfig.CorrelationID); err != nil {
				log.Entry().WithError(err).Warn("failed to set up SAP Alert Notification Service log hook")
			}

			validation, err := validation.New(validation.WithJSONNamesForStructFields(), validation.WithPredefinedErrorMessages())
			if err != nil {
				return err
			}
			if err = validation.ValidateStruct(stepConfig); err != nil {
				log.SetErrorCategory(log.ErrorConfiguration)
				return err
			}

			return nil
		},
		Run: func(_ *cobra.Command, _ []string) {
			vaultClient := config.GlobalVaultClient()
			if vaultClient != nil {
				defer vaultClient.MustRevokeToken()
			}

			stepTelemetryData := telemetry.CustomData{}
			stepTelemetryData.ErrorCode = "1"
			handler := func() {
				config.RemoveVaultSecretFiles()
				stepTelemetryData.Duration = fmt.Sprintf("%v", time.Since(startTime).Milliseconds())
				stepTelemetryData.ErrorCategory = log.GetErrorCategory().String()
				stepTelemetryData.PiperCommitHash = piperOsCmd.GitCommit
				telemetryClient.SetData(&stepTelemetryData)
				telemetryClient.LogStepTelemetryData()
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Dsn,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Token,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.Index,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if len(piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint) > 0 {
					splunkClient.Initialize(piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblEndpoint,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblToken,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.ProdCriblIndex,
						piperOsCmd.GeneralConfig.HookConfig.SplunkConfig.SendLogs)
					splunkClient.Send(telemetryClient.GetData(), logCollector)
				}
				if piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Enabled {
					err := gcp.NewGcpPubsubClient(
						vaultClient,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.ProjectNumber,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityPool,
						piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.IdentityProvider,
						piperOsCmd.GeneralConfig.CorrelationID,
						piperOsCmd.GeneralConfig.HookConfig.OIDCConfig.RoleID,
					).Publish(piperOsCmd.GeneralConfig.HookConfig.GCPPubSubConfig.Topic, telemetryClient.GetDataBytes())
					if err != nil {
						log.Entry().WithError(err).Warn("event publish failed")
					}
				}
			}
			log.DeferExitHandler(handler)
			defer handler()
			telemetryClient.Initialize(STEP_NAME)
			sapExecuteCustomPolicy(stepConfig, &stepTelemetryData)
			stepTelemetryData.ErrorCode = "0"
			log.Entry().Info("SUCCESS")
		},
	}

	addSapExecuteCustomPolicyFlags(createSapExecuteCustomPolicyCmd, &stepConfig)
	return createSapExecuteCustomPolicyCmd
}

func addSapExecuteCustomPolicyFlags(cmd *cobra.Command, stepConfig *sapExecuteCustomPolicyOptions) {
	cmd.Flags().StringVar(&stepConfig.PolicyKey, "policyKey", os.Getenv("PIPER_policyKey"), "The key of the policy to be executed. The key is annotated in the metadata in the policy.")
	cmd.Flags().StringVar(&stepConfig.EvidenceFile, "evidenceFile", os.Getenv("PIPER_evidenceFile"), "The evidence file to be evaluated.")
	cmd.Flags().StringVar(&stepConfig.PolicyPath, "policyPath", `.policy`, "Path of a directory containing the policies.")
	cmd.Flags().BoolVar(&stepConfig.FailOnPolicyViolation, "failOnPolicyViolation", true, "Fail the pipeline if the policy is not compliant.")
	cmd.Flags().StringVar(&stepConfig.ResultFile, "resultFile", `./custom-policy-result/<policyKey>/result.json`, "Path of the result file that is generated. The placeholder <policyKey> will be replaced by the policy key.\nThe path can contain subfolders which might be useful if the same policy is executed multiple times (e.g. mono repo / maven multi module project)\nAttention: If you execute the same policy multiple times without specifying resultFile parameter results will be overwritten.\n")
	cmd.Flags().BoolVar(&stepConfig.GenerateJunitReport, "generateJunitReport", false, "Whether a junit test-report xml is generated or not. If so, the report will be generated at the following path: ./TEST-custom-policy-<policyKey>.xml\n")
	cmd.Flags().StringVar(&stepConfig.GithubToken, "githubToken", os.Getenv("PIPER_githubToken"), "Token of Git user for GitHub access. Required if pipeline is running outside of the corporate network.")
	cmd.Flags().StringVar(&stepConfig.CumulusPolicyAgentVersion, "cumulusPolicyAgentVersion", `latest`, "The version of the cumulus policy agent to be used for the execution.\nNote: Normally you should use the default\n")

	cmd.MarkFlagRequired("policyKey")
	cmd.MarkFlagRequired("evidenceFile")
}

// retrieve step metadata
func sapExecuteCustomPolicyMetadata() config.StepData {
	var theMetaData = config.StepData{
		Metadata: config.StepMetadata{
			Name:        "sapExecuteCustomPolicy",
			Aliases:     []config.Alias{},
			Description: "Execute a custom policy.",
		},
		Spec: config.StepSpec{
			Inputs: config.StepInputs{
				Secrets: []config.StepSecrets{
					{Name: "githubTokenCredentialsId", Description: "Jenkins 'Secret text' credentials ID containing the token used to authenticate with the Github server.", Type: "jenkins"},
				},
				Parameters: []config.StepParameters{
					{
						Name:        "policyKey",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_policyKey"),
					},
					{
						Name:        "evidenceFile",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS"},
						Type:        "string",
						Mandatory:   true,
						Aliases:     []config.Alias{},
						Default:     os.Getenv("PIPER_evidenceFile"),
					},
					{
						Name:        "policyPath",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "GENERAL"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `.policy`,
					},
					{
						Name:        "failOnPolicyViolation",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "GENERAL"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     true,
					},
					{
						Name:        "resultFile",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `./custom-policy-result/<policyKey>/result.json`,
					},
					{
						Name:        "generateJunitReport",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS"},
						Type:        "bool",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     false,
					},
					{
						Name: "githubToken",
						ResourceRef: []config.ResourceReference{
							{
								Name: "githubTokenCredentialsId",
								Type: "secret",
							},

							{
								Name:    "githubTokenCredentialsVaultSecretName",
								Type:    "vaultSecret",
								Default: "github",
							},
						},
						Scope:     []string{"PARAMETERS", "STEPS"},
						Type:      "string",
						Mandatory: false,
						Aliases:   []config.Alias{{Name: "access_token"}},
						Default:   os.Getenv("PIPER_githubToken"),
					},
					{
						Name:        "cumulusPolicyAgentVersion",
						ResourceRef: []config.ResourceReference{},
						Scope:       []string{"PARAMETERS", "STEPS", "GENERAL"},
						Type:        "string",
						Mandatory:   false,
						Aliases:     []config.Alias{},
						Default:     `latest`,
					},
				},
			},
		},
	}
	return theMetaData
}
