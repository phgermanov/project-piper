import com.sap.piper.internal.JenkinsUtils
import com.sap.icd.jenkins.Utils
import com.sap.piper.internal.ConfigurationHelper
import groovy.text.GStringTemplateEngine
import groovy.transform.Field
import com.sap.piper.GenerateDocumentation

import static com.sap.piper.internal.Prerequisites.checkScript

@Field String STEP_NAME = 'sapCreateTraceabilityReport'
@Field Set GENERAL_CONFIG_KEYS = [
    /** HTTP url of GitHub/GitHub Enterprise server*/
    'githubServerUrl',
    /** HTTP url of Jira server*/
    'jiraServerUrl',
    /**
     * Print more detailed information into the log.
     * @possibleValues `true`, `false`
     */
    'verbose'
]
@Field Set STEP_CONFIG_KEYS = GENERAL_CONFIG_KEYS.plus([
    /** Name of the delivery mapping file in case the default name is not used.*/
    'deliveryMappingFile',
    /**
     * In case the step should not fail even though not all requirements are tested successfully, failOnError can be set to false.
     * @possibleValues `true`, `false`
     * */
    'failOnError',
    /** Title of the traceability report*/
    'reportTitle',
    /** Name of the requirment mapping file in case the default name is not used.*/
    'requirementMappingFile',
    /** List of stash names to be considered for unstashing before executing the check.*/
    'stashContent',
    /**
     * For css styling of the document a custom style can be used. The custom css is passed as text via the style parameter.
     * The default style can be found in the file piper.css
     * */
    'style',
    /** Name of application component to be used for test case which is created.*/
    'terApplicationComponent',
    /** HTTP url to server running TER service. */
    'terServerUrl',
    /** Source id of the test results, defaults to `env.JOB_BASE_NAME`*/
    'terSourceId',
    /**
     * Optional parameter to provide name of the test set attribute at the test plan during creation.
     * Value is restricted to 20 chars, alpha-numeric, Upper case
     * */
    'terTestSet',
    /** Id of the Jenkins credentials containing the TER service token.
     * The token can be generated by calling the service endpoint [/authorization/handshake](https://ter.tools.sap.corp/v1/api/authorization/handshake).
     * */
    'terTokenCredentialsId',
    /** TER service API endpoint for test result upload.*/
    'terUploadEndpoint',
    /** Defines if validation should be performed before upload of test results.*/
    'terValidation',
    /** TER service API endpoint for content validation.*/
    'terValidationEndpoint',
    /** Define if test mappings for all requirements should be checked and uploaded. If set to false, only delivery-relevant requirements are taken into consideration. */
    'checkAllRequirements'
])
@Field Set PARAMETER_KEYS = STEP_CONFIG_KEYS


@GenerateDocumentation
def call(Map parameters = [:]) {
    handlePipelineStepErrors (stepName: STEP_NAME, stepParameters: parameters,
        libraryDocumentationUrl: 'https://go.sap.corp/piper/',
        libraryRepositoryUrl: 'https://github.wdf.sap.corp/ContinuousDelivery/piper-library/'
    ) {
        def script = checkScript(this, parameters) ?: this
        def utils = parameters.juStabUtils ?: new Utils()
        def jenkinsUtils = parameters.jenkinsUtilsStub ?: new JenkinsUtils()
        // load default & individual configuration
        Map config = ConfigurationHelper
            .loadStepDefaults(this)
            .mixinGeneralConfig(script.globalPipelineEnvironment, GENERAL_CONFIG_KEYS)
            .mixinStepConfig(script.globalPipelineEnvironment, STEP_CONFIG_KEYS)
            .mixinStageConfig(script.globalPipelineEnvironment, parameters.stageName?:env.STAGE_NAME, STEP_CONFIG_KEYS)
            .mixin(style: libraryResource('piper.css'))
            .mixin(parameters, PARAMETER_KEYS)
            .addIfEmpty('terSourceId', env.JOB_BASE_NAME)
            .use()

        config.terUpload =  config.terTokenCredentialsId != null

        script.globalPipelineEnvironment.setInfluxStepData('traceability', false)

        config.stashContent = utils.unstashAll(config.stashContent)

        def deliveryMapping = readJSON(text: readFile(file: config.deliveryMappingFile).trim())
        def requirementMapping = readJSON(text: readFile(file: config.requirementMappingFile).trim())

        try {
            requirementMapping =  jenkinsUtils.getRequirementResultMapping(requirementMapping)
        } catch (err) {
            error("[${STEP_NAME}] Failed to retrieve test results - please make sure that test results have been uploaded to Jenkins job. Error: ${err}")
        }


        def testResults = [:]
        def deliveryTestResults = [:]

        deliveryMapping.jira_keys.each {jiraKey ->
            deliveryTestResults[jiraKey] = [title: 'n/a', link: "${config.jiraServerUrl}/browse/${jiraKey}", test_cases: []]
        }
        deliveryMapping.github_keys.each {githubKey ->
            deliveryTestResults[githubKey] = [title: 'n/a', link: "${config.githubServerUrl}/${githubKey.replace('#','/issues/')}", test_cases: []]
        }

        requirementMapping.each {
            for (def i=0; i<it.jira_keys?.size(); i++) {
                if (testResults[it.jira_keys[i]] == null) {
                    testResults[it.jira_keys[i]] = [title: 'n/a', link: "${config.jiraServerUrl}/browse/${it.jira_keys[i]}", test_cases: []]
                }
                if (it.test_cases != null) {
                    testResults[it.jira_keys[i]].test_cases.addAll(it.test_cases)
                    if (deliveryMapping.jira_keys.contains(it.jira_keys[i]))
                        deliveryTestResults[it.jira_keys[i]].test_cases.addAll(it.test_cases)
                } else {
                    def testCase = [
                        test_fullname: it.source_reference,
                        test_name: '',
                        test_class: '',
                        passed: false,
                        skipped: true
                    ]
                    testResults[it.jira_keys[i]].test_cases.add(testCase)
                    if (deliveryMapping.jira_keys.contains(it.jira_keys[i]))
                        deliveryTestResults[it.jira_keys[i]].test_cases.add(testCase)
                }
            }
            for (def i=0; i<it.github_keys?.size(); i++) {
                if (testResults[it.github_keys[i]] == null) {
                    testResults[it.github_keys[i]] = [title: 'n/a', link: "${config.githubServerUrl}/${(it.github_keys[i]).replace('#','/issues/')}", test_cases: []]
                }
                if (it.test_cases != null) {
                    testResults[it.github_keys[i]].test_cases.addAll(it.test_cases)
                    if (deliveryMapping.github_keys.contains(it.github_keys[i]))
                        deliveryTestResults[it.github_keys[i]].test_cases.addAll(it.test_cases)
                } else {
                    def testCase = [
                        test_fullname: it.source_reference,
                        test_name: '',
                        test_class: '',
                        passed: false,
                        skipped: true
                    ]
                    testResults[it.github_keys[i]].test_cases.add(testCase)
                    if (deliveryMapping.github_keys.contains(it.github_keys[i]))
                        deliveryTestResults[it.github_keys[i]].test_cases.add(testCase)
                }
            }
        }

        def sortedAllResults = testResults.sort()
        def sortedDeliveryResults = deliveryTestResults.sort()

        writeFile file: 'piper_traceability_all.json', text: utils.getPrettyJsonString(sortedAllResults)
        writeFile file: 'piper_traceability_all.html', text: getTraceabilityHtml(sortedAllResults, config)
        writeFile file: 'piper_traceability_delivery.json', text: utils.getPrettyJsonString(sortedDeliveryResults)
        writeFile file: 'piper_traceability_delivery.html', text: getTraceabilityHtml(sortedDeliveryResults, config, deliveryMapping.sirius_program, deliveryMapping.sirius_delivery)

        archiveArtifacts 'piper_traceability_all.*, piper_traceability_delivery.*'

        Map resultsToCheck = sortedDeliveryResults
        if (config.checkAllRequirements) {
            resultsToCheck = sortedAllResults
        }

        def totalRequirements = resultsToCheck.size()
        def successfulRequirements = 0

        resultsToCheck.each { reqs ->
            if (reqs.getValue().test_cases.size() > 0 && reqs.getValue().test_cases.count { !it.passed } == 0)
                successfulRequirements++
        }

        boolean terSuccess = true
        String terErrorMessage = ''
        if (config.terUpload) {
            try {
                uploadToTERSystem(utils, config, deliveryMapping.sirius_program, deliveryMapping.sirius_delivery, resultsToCheck)
            } catch (err) {
                if (err.getMessage().contains('validation failed')) {
                    terErrorMessage = "[${STEP_NAME}] ${err.getMessage()}"
                } else {
                    terErrorMessage = "[${STEP_NAME}] TER upload failed: ${err}"
                }
                echo terErrorMessage
                terSuccess = false
            }
        }

        if (config.failOnError && successfulRequirements < totalRequirements)
            error "[${STEP_NAME}] only ${successfulRequirements} of ${totalRequirements} requirements fulfilled"

        if (successfulRequirements == totalRequirements)
            script.globalPipelineEnvironment.setInfluxStepData('traceability', true)

        if (config.failOnError && !terSuccess)
            error "${terErrorMessage}"

    }
}

private String getTraceabilityHtml(testMapping, config, program='', delivery='') {

    def traceabilityTable = ''
    def now = new Date().format( 'MMM dd, yyyy - HH:mm:ss' )

    def totalRequirements = testMapping.size()
    def successfulRequirements = 0

    testMapping.each { reqs ->
        if (reqs.getValue().test_cases.size() > 0 && reqs.getValue().test_cases.count { !it.passed } == 0)
            successfulRequirements++
    }

    if (testMapping.size() == 0)
        traceabilityTable += '<tr><td colspan=7>No issues found</td></tr>'
    def counter = 0
    testMapping.each {
        counter ++
        traceabilityTable += "<tr><td>${counter}</td><td><a href=\"${it.getValue().link}\" target=\"_blank\">${it.getKey()}</a></td><!--<td>${it.getValue().title}</td>--><td><div><ul class=\"nobullets\">"
        if (it.getValue().test_cases.size() == 0)
            traceabilityTable + "<li class=\"notok\"><span style=\"float:left; width: 4em\">not OK:</span>no test mapping found</li>"
        for (def i=0; i<it.getValue().test_cases.size(); i++) {
            traceabilityTable += "<li class=\"${it.getValue().test_cases[i].passed?'ok':'notok'}\"><span style=\"float:left; width: 4em\">${it.getValue().test_cases[i].passed?'OK':'not OK'}:</span>${it.getValue().test_cases[i].test_fullname}</li>"
        }
        traceabilityTable += '</ul></div></td></tr>'
    }

    return GStringTemplateEngine.newInstance().createTemplate(libraryResource('com.sap.piper.internal/templates/traceability.html')).make(
        [
            delivery: delivery,
            now: now,
            program: program,
            reportTitle: config.reportTitle,
            style: config.style,
            successfulRequirements: successfulRequirements,
            totalRequirements: totalRequirements,
            traceabilityTable: traceabilityTable
        ]).toString()
}

private void uploadToTERSystem(utils, config, siriusProgram, siriusDelivery, traceabilityData) {

    Map terMap = [
        siriusProgramName: siriusProgram,
        deliveryName: siriusDelivery,
        sourceId: config.terSourceId,
        fc2Content: traceabilityData
    ]

    if (config.terApplicationComponent)
        terMap.applicationComponent = config.terApplicationComponent

    if (config.terTestSet)
        terMap.testSet = config.terTestSet

    withCredentials([string(credentialsId: config.terTokenCredentialsId, variable: 'terToken')]) {

        def requestBody = utils.getPrettyJsonString(terMap)
        def uploadResponse = [:]

        try {
            if (config.terValidation) {
                def validationResponse = httpRequest url: "${config.terServerUrl}${config.terValidationEndpoint}", requestBody: requestBody, contentType: 'APPLICATION_JSON', httpMode: 'POST', customHeaders: [[name: 'Authorization', value: terToken]], consoleLogResponseBody: config.verbose, responseHandle: 'NONE'
                if (config.verbose) {
                    echo "[${STEP_NAME}] TER Validation - HTTP Request Body: ${requestBody}"
                    echo "[${STEP_NAME}] TER Validation - HTTP Response Status: ${validationResponse.status}"
                }
                Map validationResult = readJSON text: validationResponse.content
                if (!validationResult.validationPassed) error("TER validation failed with message ${validationResult.message} and errors ${validationResult.errors}")
            }
            uploadResponse = httpRequest url: "${config.terServerUrl}${config.terUploadEndpoint}", requestBody: requestBody, contentType: 'APPLICATION_JSON', httpMode: 'POST', customHeaders: [[name: 'Authorization', value: terToken]], consoleLogResponseBody: config.verbose, responseHandle: 'NONE'
        } finally {
            if (config.verbose) {
                echo "[${STEP_NAME}] TER Upload - HTTP Request Body: ${requestBody}"
                echo "[${STEP_NAME}] TER Upload - HTTP Response Status: ${uploadResponse.status}"
                echo "[${STEP_NAME}] TER Upload - HTTP Response Content: ${uploadResponse.content}"
            }
        }
    }
}
